### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/__init__.py ###
# panorai/__init__.py

# Import core pipeline components
from .pipeline.pipeline import ProjectionPipeline, PipelineConfig
from .pipeline.pipeline_data import PipelineData
from .pipeline.utils.resizer import ResizerConfig
from .common import PipelineFullConfig

# Import sampler components
from .sampler.sampler import SamplerConfig, CubeSampler, IcosahedronSampler, FibonacciSampler

# Import projection components
#from .projection_deprecated.projector import ProjectorConfig, GnomonicProjector
#from .projection_deprecated.utils.remapper import RemapConfig
#from .projection_deprecated.utils.unsharp import UnsharpMaskConfig

# Define the public API for panorai
__all__ = [
    # Pipeline
    "ProjectionPipeline", "PipelineConfig", "ProjectionData", "ResizerConfig", "PipelineFullConfig",
    # Sampler
    "SamplerConfig", "CubeSampler", "IcosahedronSampler", "FibonacciSampler",
    # Projection
    #"ProjectorConfig", "GnomonicProjector", "RemapConfig", "UnsharpMaskConfig"
]

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/common/__init__.py ###
# panorai/shared/__init__.py

from .shared_config import PipelineFullConfig

__all__ = [
    "PipelineFullConfig",
]

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/common/shared_config.py ###
import cv2
from ..projection_deprecated.projector import ProjectorConfig
from ..projection_deprecated.projector import UnsharpMaskConfig
from ..projection_deprecated.projector import RemapConfig
from ..pipeline import ResizerConfig, ProjectionPipeline
from ..sampler.sampler import SamplerConfig
from ..pipeline import PipelineConfig



class PipelineFullConfig:
    """Unified configuration for the ProjectionPipeline and its sub-components."""

    def __init__(
        self,
        dims=(1024, 1024),
        shadow_angle_deg=30,
        projector_cls="GnomonicProjector",
        unsharp=False,
        unsharp_sigma=1.0,
        unsharp_kernel_size=7,
        unsharp_strength=1.5,
        remap_method="ndimage",
        remap_order=3,
        remap_prefilter=True,
        remap_mode="nearest",
        remap_interpolation=cv2.INTER_CUBIC,
        remap_border_mode=cv2.BORDER_WRAP,
        sampler_cls="CubeSampler",
        sampler_kwargs=None,
        resize_factor=1.0,
        n_jobs=1,
    ):
        """
        Initialize a unified configuration for the ProjectionPipeline.

        :param dims: Tuple (height, width) for projection dimensions.
        :param shadow_angle_deg: Shadow angle for the projector.
        :param projector_cls: Projector class name or class.
        :param unsharp: Whether to apply unsharp masking.
        :param unsharp_sigma: Sigma for unsharp masking Gaussian blur.
        :param unsharp_kernel_size: Kernel size for unsharp masking (odd number).
        :param unsharp_strength: Strength of unsharp masking.
        :param remap_method: Method for remapping ('ndimage' or 'cv2').
        :param remap_order: Order of interpolation for remapping (ndimage).
        :param remap_prefilter: Prefilter option for remapping (ndimage).
        :param remap_mode: Out-of-bounds mode for remapping (ndimage).
        :param remap_interpolation: Interpolation method for remapping (cv2).
        :param remap_border_mode: Border handling mode for remapping (cv2).
        :param sampler_cls: Sampler class name or class.
        :param sampler_kwargs: Additional arguments for the sampler.
        :param resize_factor: Resize factor for the pipeline resizer.
        :param n_jobs: Number of parallel calls to proejctor.backward.
        """
        # Initialize projector configuration parameters
        self.dims = dims
        self.shadow_angle_deg = shadow_angle_deg
        self.projector_cls = projector_cls
        self.unsharp = unsharp
        self.unsharp_sigma = unsharp_sigma
        self.unsharp_kernel_size = unsharp_kernel_size
        self.unsharp_strength = unsharp_strength

        # Initialize remap configuration parameters
        self.remap_method = remap_method
        self.remap_order = remap_order
        self.remap_prefilter = remap_prefilter
        self.remap_mode = remap_mode
        self.remap_interpolation = remap_interpolation
        self.remap_border_mode = remap_border_mode

        # Initialize sampler configuration
        self.sampler_cls = sampler_cls
        self.sampler_kwargs = sampler_kwargs or {}

        # Initialize pipeline-level configuration
        self.resize_factor = resize_factor
        self.n_jobs = n_jobs

    def create_pipeline(self):
        """
        Instantiate the ProjectionPipeline using the stored configuration.

        :return: A configured ProjectionPipeline instance.
        """
        # Create projector configuration
        projector_cfg = ProjectorConfig(
            dims=self.dims,
            shadow_angle_deg=self.shadow_angle_deg,
            projector_cls=self.projector_cls,
            unsharp=self.unsharp,
            unsharp_cfg=UnsharpMaskConfig(
                sigma=self.unsharp_sigma,
                kernel_size=self.unsharp_kernel_size,
                strength=self.unsharp_strength,
            ),
            remap_cfg=RemapConfig(
                method=self.remap_method,
                order=self.remap_order,
                prefilter=self.remap_prefilter,
                mode=self.remap_mode,
                interpolation=self.remap_interpolation,
                border_mode=self.remap_border_mode,
            ),
        )

        # Create sampler configuration
        sampler_cfg = SamplerConfig(
            sampler_cls=self.sampler_cls,
            **self.sampler_kwargs,
        )

        # Create pipeline-level configuration
        pipeline_cfg = PipelineConfig(
            resizer_cfg=ResizerConfig(resize_factor=self.resize_factor),
            n_jobs=self.n_jobs
        )

        # Return a fully configured pipeline
        return ProjectionPipeline(
            projector_cfg=projector_cfg,
            pipeline_cfg=pipeline_cfg,
            sampler_cfg=sampler_cfg,
        )

    def __repr__(self):
        """
        String representation of the full configuration.
        """
        return (
            f"PipelineFullConfig(\n"
            f"  dims={self.dims},\n"
            f"  shadow_angle_deg={self.shadow_angle_deg},\n"
            f"  projector_cls={self.projector_cls},\n"
            f"  unsharp={self.unsharp},\n"
            f"  unsharp_sigma={self.unsharp_sigma},\n"
            f"  unsharp_kernel_size={self.unsharp_kernel_size},\n"
            f"  unsharp_strength={self.unsharp_strength},\n"
            f"  remap_method={self.remap_method},\n"
            f"  remap_order={self.remap_order},\n"
            f"  remap_prefilter={self.remap_prefilter},\n"
            f"  remap_mode={self.remap_mode},\n"
            f"  remap_interpolation={self.remap_interpolation},\n"
            f"  remap_border_mode={self.remap_border_mode},\n"
            f"  sampler_cls={self.sampler_cls},\n"
            f"  sampler_kwargs={self.sampler_kwargs},\n"
            f"  resize_factor={self.resize_factor}\n"
            f")"
        )

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/deprecated/pipeline.py ###
from projector import deg_to_rad 
import numpy as np
from SphereKit.panorai.pipeline.projection_data import ProjectionData
from skimage.transform import resize
        
import logging
import os
# Configure logging for Jupyter notebooks or scripts
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG if os.environ.get('DEBUG', 'False').lower() in ('true', '1') else logging.INFO)

import sys
stream_handler = logging.StreamHandler(sys.stdout)
stream_handler.setLevel(logger.level)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
stream_handler.setFormatter(formatter)
logger.handlers = [stream_handler]  # Replace existing handlers

from resizer import ResizerConfig
from sampler import SamplerConfig
from projector import ProjectorConfig

class PipelineConfig:
    """Configuration for the pipeline."""
    def __init__(self, resizer_cfg=None, resize_factor=1.0):
        """
        Initialize pipeline-level configuration.

        :param resize_factor: Factor by which to resize input images before projection.
        """
        
        self.resizer_cfg = resizer_cfg or ResizerConfig(resize_factor=resize_factor)
        
class ProjectionPipeline:
    """
    Manages sampling and projection strategies using modular configuration objects.
    """
    def __init__(self, projector_cfg: ProjectorConfig = None, pipeline_cfg: PipelineConfig = None, sampler_cfg: SamplerConfig = None):
        """
        Initialize the pipeline with configuration objects.

        :param sampler_cfg: Configuration for the sampler (optional).
        :param projector_cfg: Configuration for the projector (optional).
        :param pipeline_cfg: Configuration for the pipeline (optional).
        """
        # Use default configurations if not provided
        self.sampler_cfg = sampler_cfg or SamplerConfig(sampler_cls="CubeSampler")
        self.projector_cfg = projector_cfg or ProjectorConfig(dims=(1024, 1024), shadow_angle_deg=30, unsharp=False)
        self.pipeline_cfg = pipeline_cfg or PipelineConfig(resize_factor=1.)

        # Initialize sampler and projector
        self.sampler = self.sampler_cfg.create_sampler()
        self.projector = self.projector_cfg.create_projector()
        self.resizer = self.pipeline_cfg.resizer_cfg.create_resizer()

    def _resize_image(self, img, upsample=True):
        """
        Resize the input image using the ImageResizer.

        :param img: Input image as a NumPy array.
        :return: Resized image.
        """
        return self.resizer.resize_image(img, upsample)
    
    def _prepare_data(self, data):
        """
        Prepare data for projection. Converts single images into a dictionary format.

        :param data: ProjectionData or a single NumPy image.
        :return: Dictionary with keys as data names and values as NumPy arrays.
        """
        if isinstance(data, ProjectionData):
            return {k: self._resize_image(v) for k,v in data.as_dict().items()}
        elif isinstance(data, np.ndarray):
            return {"rgb": self._resize_image(data)}
        else:
            raise TypeError("Data must be either a ProjectionData instance or a NumPy array.")

    def set_sampler(self, sampler):
        """Set the sphere sampler."""
        self.sampler = sampler

    def set_projector(self, projector):
        """Set the projection strategy."""
        self.projector = projector

    # === Forward Projections ===
    def project_with_sampler(self, data, fov=(1, 1)):
        """
        Perform forward projection for all tangent points in the sampler.

        :param data: ProjectionData or a single NumPy image.
        :param fov: Field of view (height, width).
        :return: Dictionary with projections for each data type and tangent point.
        """
        if not self.sampler:
            raise ValueError("Sampler is not set.")
        tangent_points = self.sampler.get_tangent_points()
        prepared_data = self._prepare_data(data)
        projections = {name: {} for name in prepared_data.keys()}

        for idx, (lat, lon) in enumerate(tangent_points):
            lat = deg_to_rad(lat)
            lon = deg_to_rad(lon)
            for name, img in prepared_data.items():
                projections[name][f"point_{idx + 1}"] = self.projector.forward(img, lat, lon, fov)
        return projections

    def single_projection(self, data, lat_center, lon_center, fov=(1, 1)):
        """
        Perform a single forward projection for multiple inputs.

        :param data: ProjectionData or a single NumPy image.
        :param lat_center: Latitude center for the projection.
        :param lon_center: Longitude center for the projection.
        :param fov: Field of view (height, width).
        :return: Dictionary with projections for each data type or a single NumPy array.
        """
        lat_center = deg_to_rad(lat_center)
        lon_center = deg_to_rad(lon_center)
        prepared_data = self._prepare_data(data)
        projections = {name: self.projector.forward(img, lat_center, lon_center, fov) for name, img in prepared_data.items()}
        
        # If the input was a single image, return only the image result
        if isinstance(data, np.ndarray):
            return list(projections.values())[0]
        return projections

    # === Backward Projections ===
    def backward_with_sampler(self, rect_data, img_shape, fov=(1, 1)):
        """
        Perform backward projection for all tangent points in the sampler and combine results into a single image.
    
        :param rect_data: Dictionary of rectilinear images (outputs of forward projections).
        :param img_shape: Shape of the original spherical image (H, W, C).
        :param fov: Field of view (height, width).
        :return: Combined equirectangular image as a NumPy array.
        """
        if not self.sampler:
            raise ValueError("Sampler is not set.")
        
        tangent_points = self.sampler.get_tangent_points()
        combined_image = np.zeros(img_shape, dtype=np.float32)
        weight_map = np.zeros(img_shape[:2], dtype=np.float32)  # Weight map to handle overlaps
    
        for idx, (lat, lon) in enumerate(tangent_points):
            lat = deg_to_rad(lat)
            lon = deg_to_rad(lon)
            for name, images in rect_data.items():
                rect_img = images.get(f"point_{idx + 1}")  # Extract the NumPy array for this tangent point
                if rect_img is None:
                    raise ValueError(f"Missing projection for point_{idx + 1} in rect_data[{name}].")
                
                # Perform backward projection
                equirect_img = self.projector.backward(rect_img, img_shape, lat, lon, fov)
    
                # Combine using a weighted approach
                mask = (equirect_img.sum(axis=-1) > 0).astype(np.float32)  # Non-zero pixel mask
                combined_image += equirect_img * mask[..., None]  # Accumulate pixels
                weight_map += mask  # Update weight map
    
        # Normalize combined image by weight map to handle overlaps
        weight_map = np.maximum(weight_map, 1)  # Avoid division by zero
        combined_image /= weight_map[..., None]
    
        return combined_image.astype(np.uint8)

    def single_backward(self, rect_data, img_shape, lat_center, lon_center, fov=(1, 1)):
        """
        Perform a single backward projection for multiple inputs.

        :param rect_data: Dictionary of rectilinear images or a single image.
        :param img_shape: Shape of the original spherical image (H, W, C).
        :param lat_center: Latitude center for the projection.
        :param lon_center: Longitude center for the projection.
        :param fov: Field of view (height, width).
        :return: Dictionary with projections for each data type or a single NumPy array.
        """
        lat_center = deg_to_rad(lat_center)
        lon_center = deg_to_rad(lon_center)

        if isinstance(rect_data, np.ndarray):
            rect_data = {"rgb": rect_data}

        projections = {name: self.projector.backward(img, img_shape, lat_center, lon_center, fov) for name, img in rect_data.items()}

        if len(rect_data) == 1 and "rgb" in rect_data:
            return list(projections.values())[0]
        return projections

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/pipeline/__init__.py ###
# pipeline/__init__.py

from .pipeline import ProjectionPipeline, PipelineConfig
from .pipeline_data import PipelineData
from .utils.resizer import ResizerConfig
from .utils.preprocess_eq import PreprocessEquirectangularImage

__all__ = ["ProjectionPipeline", "PipelineConfig", "PipelineData", "ResizerConfig", "PreprocessEquirectangularImage"]

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/pipeline/pipeline.py ###
from ..projection.projector import deg_to_rad, rad_to_deg
import numpy as np

import numpy as np
from .pipeline_data import PipelineData
from skimage.transform import resize
        
import logging
import os
import sys

# For parallelization
from joblib import Parallel, delayed

from .utils.resizer import ResizerConfig
from ..sampler import SamplerConfig
from ..projection import ProjectorConfig
from ..submodules.projections import ProjectionRegistry

# Configure logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG if os.environ.get('DEBUG', 'False').lower() in ('true', '1') else logging.INFO)

stream_handler = logging.StreamHandler(sys.stdout)
stream_handler.setLevel(logger.level)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
stream_handler.setFormatter(formatter)
logger.handlers = [stream_handler]  # Replace existing handlers

class PipelineConfig:
    """Configuration for the pipeline."""
    def __init__(self, resizer_cfg=None, resize_factor=1.0, n_jobs=1):
        """
        Initialize pipeline-level configuration.

        :param resize_factor: Factor by which to resize input images before projection.
        """
        self.resizer_cfg = resizer_cfg or ResizerConfig(resize_factor=resize_factor)
        self.n_jobs = n_jobs

from ..projection.projector import deg_to_rad
import numpy as np
from .pipeline_data import PipelineData
from skimage.transform import resize
import logging
import os
import sys

# Parallel
from joblib import Parallel, delayed
from .utils.resizer import ResizerConfig
from ..sampler import SamplerConfig
from ..projection import ProjectorConfig

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG if os.environ.get('DEBUG', 'False').lower() in ('true', '1') else logging.INFO)

stream_handler = logging.StreamHandler(sys.stdout)
stream_handler.setLevel(logger.level)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
stream_handler.setFormatter(formatter)
logger.handlers = [stream_handler]

class PipelineConfig:
    """Configuration for the pipeline."""
    def __init__(self, resizer_cfg=None, resize_factor=1.0, n_jobs=1):
        self.resizer_cfg = resizer_cfg or ResizerConfig(resize_factor=resize_factor)
        self.n_jobs = n_jobs


class ProjectionPipeline:
    """
    Manages sampling and projection strategies using modular configuration objects.
    Stacks all data channels into one multi-channel array for forward/backward operations,
    automatically un-stacks after backward if input was PipelineData.

    Additionally, if stacking is used in forward pass, we override `img_shape` in 
    backward pass to the actual stacked shape, preventing shape mismatches.
    """
    def __init__(
        self,
        projection_name: str = None,
        pipeline_cfg: PipelineConfig = None,
        sampler_cfg: SamplerConfig = None,
    ):
        """
        :param projector_cfg: Configuration for the projector (optional).
        :param pipeline_cfg: PipelineConfig (optional).
        :param sampler_cfg: SamplerConfig (optional).
        """
        # Default configurations
        self.sampler_cfg = sampler_cfg or SamplerConfig(sampler_cls="CubeSampler")
        #self.projector_cfg = projector_cfg or ProjectorConfig(dims=(1024, 1024), shadow_angle_deg=30, unsharp=False)
        self.pipeline_cfg = pipeline_cfg or PipelineConfig(resize_factor=1.0)

        # Create sampler, projector, resizer
        self.sampler = self.sampler_cfg.create_sampler()
        self.projector = ProjectionRegistry.get_projection(projection_name,return_processor=True)
        self.resizer = self.pipeline_cfg.resizer_cfg.create_resizer()

        # Parallel setting
        self.n_jobs = self.pipeline_cfg.n_jobs

        # For un-stacking after backward:
        self._original_data = None   # the PipelineData if used
        self._keys_order = None      # list of data keys from stack_all
        self._stacked_shape = None   # shape (H, W, total_channels) from forward pass

    def _resize_image(self, img, upsample=True):
        """Resize the input image using the ImageResizer."""
        return self.resizer.resize_image(img, upsample)
    
    def _prepare_data(self, data):
        """
        If data is PipelineData, call data.stack_all() => single (H, W, C), plus keys_order.
        Store references so we can unstack automatically after backward.
        """
        if isinstance(data, PipelineData):
            stacked, keys_order = data.stack_all()
            self._original_data = data
            self._keys_order = keys_order
            return stacked, keys_order
        elif isinstance(data, np.ndarray):
            self._original_data = None
            self._keys_order = None
            return data, None
        else:
            raise TypeError("Data must be either PipelineData or np.ndarray.")

    # === Forward Projection ===
    def project_with_sampler(self, data, **kwargs):
        """
        Forward projection on a single stacked array for all tangent points.
        Returns { "stacked": { "point_1": arr, ... } }
        """
        if not self.sampler:
            raise ValueError("Sampler is not set.")

        tangent_points = self.sampler.get_tangent_points()
        prepared_data, _ = self._prepare_data(data)
        fov_deg = kwargs.get('fov_deg',90)
        # Store the shape so backward can override
        if isinstance(prepared_data, np.ndarray):
            self._stacked_shape = prepared_data.shape
        else:
            # Should not happen, but just in case
            self._stacked_shape = None

        projections = {"stacked": {}, "unstacked": {}}
        for idx, (lat_deg, lon_deg) in enumerate(tangent_points, start=1):
            lat = deg_to_rad(lat_deg)
            lon = deg_to_rad(lon_deg)
            logger.debug(f"Forward projecting for point {idx}, lat={lat_deg}, lon={lon_deg}.")
            self.projector.config.update( phi1_deg=rad_to_deg(lat), lam0_deg=rad_to_deg(lon), fov_deg=fov_deg)
            shadow_angle = kwargs.get('shadow_angle',0)
            out_img = self.projector.forward(prepared_data,shadow_angle=shadow_angle)
            projections["stacked"][f"point_{idx}"] = out_img
            

        return projections

    def single_projection(self, data, lat_center, lon_center, fov=(1, 1)):
        """
        Single forward projection of a stacked array.
        """
        lat_center = deg_to_rad(lat_center)
        lon_center = deg_to_rad(lon_center)
        prepared_data, _ = self._prepare_data(data)
        if isinstance(prepared_data, np.ndarray):
            self._stacked_shape = prepared_data.shape
        out_img = self.projector.forward(prepared_data, lat_center, lon_center, fov)
        return out_img

    # === Backward Projection ===
    def backward_with_sampler(self, rect_data, img_shape, **kwargs):
        """
        If _stacked_shape is set from forward pass, override user-supplied `img_shape`
        to avoid shape mismatch. Then do the multi-channel backward pass, unstack if needed.

        :param rect_data: { "stacked": { "point_1": arr, ... } }
        :param img_shape: Potentially (H, W, 3) from user, but if we stacked 7 channels,
                          we override with (H, W, 7).
        :return: 
          If PipelineData was used, returns unstacked dict of { "rgb": arr, "depth": arr, ... }
          If user input was a raw array, returns { "stacked": combined }
        """
        if not self.sampler:
            raise ValueError("Sampler is not set.")

        # If we have a stacked_shape from forward, override
        if self._stacked_shape is not None:
            if img_shape != self._stacked_shape:
                logger.warning(
                    f"Overriding user-supplied img_shape={img_shape} with stacked_shape={self._stacked_shape} "
                    "to ensure consistent channel dimensions."
                )
            img_shape = self._stacked_shape

        tangent_points = self.sampler.get_tangent_points()
        combined = np.zeros(img_shape, dtype=np.float32)
        weight_map = np.zeros(img_shape[:2], dtype=np.float32)

        stacked_dict = rect_data.get("stacked")
        if stacked_dict is None:
            raise ValueError("rect_data must have a 'stacked' key with tangent-point images.")

        fov_deg = kwargs.get('fov_deg',90)
        lon_points = img_shape[1]
        lat_poonts = img_shape[0]

        tasks = []
        for idx, (lat_deg, lon_deg) in enumerate(tangent_points, start=1):
            rect_img = stacked_dict.get(f"point_{idx}")
            if rect_img is None:
                raise ValueError(f"Missing 'point_{idx}' in rect_data['stacked'].")

            if rect_img.shape[-1] != img_shape[-1]:
                raise ValueError(
                    f"rect_img has {rect_img.shape[-1]} channels, but final shape indicates {img_shape[-1]} channels.\n"
                    "Make sure the shapes match."
                )
            tasks.append((idx, lat_deg, lon_deg, rect_img))

        def _backward_task(idx, lat_deg, lon_deg, rect_img):
            logger.debug(f"[Parallel] Backward projecting point_{idx}, lat={lat_deg}, lon={lon_deg}...")

            self.projector.config.update(
                lon_points=lon_points,
                lat_points=lat_poonts,
                fov_deg=fov_deg,
                phi1_deg=lat_deg,
                lam0_deg=lon_deg,
            )

            equirect_img, mask = self.projector.backward(rect_img, return_mask=True)#, img_shape, lat, lon, fov_deg, return_mask=True)
            return idx, equirect_img, mask

        logger.info(f"Starting backward with n_jobs={self.n_jobs} on {len(tasks)} tasks.")
        results = Parallel(n_jobs=self.n_jobs)(
            delayed(_backward_task)(*task) for task in tasks
        )
        logger.info("All backward tasks completed.")

        # Merge
        for (idx, eq_img, mask) in results:
            combined += eq_img * mask[..., None]
            weight_map += mask

        # Optionally blend
        # w = np.maximum(weight_map, 1e-9)
        # combined /= w[..., None]

        # If we had PipelineData, unstack
        import matplotlib.pyplot as plt
        plt.imshow(combined[:,:,0])
        plt.show()
        plt.imshow(combined[:,:,1:4])
        plt.show()
        plt.imshow(combined[:,:,])
        plt.show()
        if self._original_data is not None and self._keys_order is not None:
            new_data = self._original_data.unstack_new_instance(combined, self._keys_order)
            return new_data.as_dict()
        else:
            return {"stacked": combined}

    def single_backward(self, rect_data, img_shape, lat_center, lon_center, fov=(1, 1)):
        """
        If we have self._stacked_shape, override user-supplied shape for channel consistency.
        If pipeline data was used, unstack automatically.
        """
        lat_center = deg_to_rad(lat_center)
        lon_center = deg_to_rad(lon_center)

        if self._stacked_shape is not None and img_shape != self._stacked_shape:
            logger.warning(
                f"Overriding user-supplied img_shape={img_shape} with stacked_shape={self._stacked_shape} "
                "for single_backward."
            )
            img_shape = self._stacked_shape

        if isinstance(rect_data, np.ndarray):
            out_img, _ = self.projector.backward(rect_data, img_shape, lat_center, lon_center, fov, return_mask=True)
            if self._original_data is not None and self._keys_order is not None:
                new_data = self._original_data.unstack_new_instance(out_img, self._keys_order)
                return new_data.as_dict()
            else:
                return out_img
        else:
            # Must have "stacked" key
            stacked_arr = rect_data.get("stacked")
            if stacked_arr is None:
                raise ValueError("Expecting key 'stacked' in rect_data for single_backward.")

            if stacked_arr.shape[-1] != img_shape[-1]:
                raise ValueError(
                    f"Stacked array has {stacked_arr.shape[-1]} channels, but final shape indicates {img_shape[-1]}.\n"
                    "Shapes must match."
                )
            out_img, _ = self.projector.backward(stacked_arr, img_shape, lat_center, lon_center, fov, return_mask=True)
            if self._original_data is not None and self._keys_order is not None:
                new_data = self._original_data.unstack_new_instance(out_img, self._keys_order)
                return new_data.as_dict()
            else:
                return out_img



### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/pipeline/pipeline_data.py ###
import numpy as np
from .utils import PreprocessEquirectangularImage
class PipelineData:
    """
    A container for paired data (e.g., RGB image, depth map, and additional arrays) for projection.
    """
    def __init__(self, rgb: np.ndarray, depth: np.ndarray = None, **kwargs):
        """
        Initialize PipelineData with RGB, optional depth, and additional data arrays.

        :param rgb: RGB image as a NumPy array (H, W, 3) typically in [0..255].
        :param depth: Depth map as a NumPy array (H, W) or (H, W, 1).
        :param kwargs: Additional data arrays, e.g., "xyz_depth" -> (H, W, 3).
        """
        # Normalize RGB by default to [0..1].
        self.data = {}
        if rgb is not None:
            # Ensure 3rd dim is 3 if it's truly RGB. Some code might pass (H, W). 
            # We'll assume shape is (H, W, 3).
            self.data["rgb"] = rgb / 255.0  
        if depth is not None:
            # shape might be (H, W) or (H, W, 1)
            self.data["depth"] = depth
        # Add any additional data arrays
        self.data.update(kwargs)

    def as_dict(self):
        """Return a dictionary of all stored arrays."""
        return self.data

    @classmethod
    def from_dict(cls, data: dict):
        """
        Create a PipelineData instance from a dictionary.

        :param data: Dictionary with keys as data names and values as NumPy arrays.
                     Must contain at least "rgb" or handle the case if missing.
        :return: PipelineData instance.
        """
        if "rgb" not in data:
            raise ValueError("The 'rgb' key is required to create PipelineData.")

        rgb = data.pop("rgb")
        depth = data.pop("depth", None)

        return cls(rgb=rgb, depth=depth, **data)

    def stack_all(self):
        """
        Stacks all channels into a single multi-channel array along the last dimension.
        Returns (H, W, total_channels).

        We assume:
          - 'rgb' is (H, W, 3)
          - 'depth' is (H, W) or (H, W, 1)
          - any additional keys, e.g. 'xyz_depth' is (H, W, 3)
        """
        # Sort keys if you want a consistent channel ordering 
        # (e.g., always stack in [rgb -> depth -> xyz_depth] order).
        # For simplicity, let's gather them in alphabetical order or define your own.
        # We'll do a stable sort by key:
        sorted_keys = sorted(self.data.keys())

        stacked_list = []
        for k in sorted_keys:
            arr = self.data[k]
            if arr.ndim == 2:
                # e.g. (H, W) -> expand to (H, W, 1)
                arr = arr[..., np.newaxis]
            stacked_list.append(arr)

        # Now we can np.concatenate along channels
        stacked = np.concatenate(stacked_list, axis=-1)
        return stacked, sorted_keys

    def unstack_all(self, stacked_array, keys_order):
        """
        Unstacks a single multi-channel array back into separate entries in self.data.

        :param stacked_array: (H, W, total_channels)
        :param keys_order: the list of keys that was used in stack_all (sorted_keys).
        :return: None (updates self.data in-place).
        """
        # We need to split the channels back in the same proportions as before.
        # We'll figure out each shape from the original arrays in self.data.

        # But note: after a forward/backward pass, shape might remain the same (H, W, C).
        # We'll rely on the original shapes from self.data to see how many channels each had.

        start_c = 0
        unstacked = {}
        for k in keys_order:
            orig = self.data[k]
            orig_shape = orig.shape  # e.g. (H, W), (H, W, 3), etc.
            if orig.ndim == 2:
                num_c = 1
            else:
                num_c = orig_shape[-1]

            # Extract the slice
            end_c = start_c + num_c
            chunk = stacked_array[..., start_c:end_c]

            # If the original was 2D, squeeze
            if orig.ndim == 2:
                chunk = chunk[..., 0]  # remove that last dimension
            #self.data[k] = chunk
            unstacked[k] = chunk
            start_c = end_c
        return unstacked

    def unstack_new_instance(self, stacked_array, keys_order):
        """
        Optionally create a new PipelineData instance with data splitted from stacked_array.
        Sometimes we don't want to mutate self.data in place.
        """
        # We'll create a new dictionary
        new_data = {}
        start_c = 0
        for k in keys_order:
            orig = self.data[k]
            if orig.ndim == 2:
                num_c = 1
            else:
                num_c = orig.shape[-1]

            end_c = start_c + num_c
            chunk = stacked_array[..., start_c:end_c]
            if orig.ndim == 2:
                chunk = chunk[..., 0]
            new_data[k] = chunk
            start_c = end_c

        # Then build a new PipelineData from the dictionary
        # we have to pass them properly (rgb, depth, or kwargs)
        # We'll do a simple approach: if 'rgb' in new_data, that's for 'rgb'; 
        # if 'depth' in new_data, for 'depth'. The rest -> kwargs
        return PipelineData.from_dict(new_data)

    def preprocess(self, shadow_angle=0, delta_lat=0, delta_lon=0):
        new_data = {}
        for k, v in self.data.items():
            new_data[k] = PreprocessEquirectangularImage.preprocess(v, shadow_angle=shadow_angle, delta_lat=delta_lat, delta_lon=delta_lon)
        self._cached_data = self.data.copy()
        self.data = new_data

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/pipeline/utils/__init__.py ###
# pipeline/utils/__init__.py

from .resizer import ResizerConfig, ImageResizer
from .preprocess_eq import PreprocessEquirectangularImage

__all__ = ["ResizerConfig", "ImageResizer", "PreprocessEquirectangularImage"]

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/pipeline/utils/preprocess_eq.py ###
import cv2
import numpy as np
import logging


class PreprocessEquirectangularImage:
    # Set up the logger for the class
    logger = logging.getLogger("EquirectangularImage")
    logger.setLevel(logging.DEBUG)

    @classmethod
    def extend_height(cls, image, shadow_angle):
        """
        Extends the height of an equirectangular image based on the given additional FOV.

        Parameters:
            image (np.ndarray): Input equirectangular image.
            shadow_angle (float): Additional field of view in degrees to extend vertically.

        Returns:
            extended_image (np.ndarray): Image with extended bottom region.
            h_prime (int): Number of rows added to the original image.
        """
        cls.logger.info("Starting height extension with shadow_angle=%.2f", shadow_angle)

        if not isinstance(image, np.ndarray):
            cls.logger.error("Image is not a valid numpy array.")
            raise TypeError("Image must be a numpy array.")
        if shadow_angle <= 0:
            cls.logger.info("No extension needed as shadow_angle=0 or less.")
            return image  # No extension needed

        fov_original = 180.0

        if len(image.shape) == 2:
            height, width = image.shape
            channels = 1
        else:
            height, width, channels = image.shape
        h_prime = int((shadow_angle / fov_original) * height)
        cls.logger.debug("Original height: %d, Additional height: %d", height, h_prime)

        black_extension = np.zeros((h_prime, width, channels), dtype=image.dtype)
        extended_image = np.vstack((image, black_extension))

        cls.logger.info("Height extension complete. New height: %d", extended_image.shape[0])
        return extended_image

    @classmethod
    def undo_extend_height(cls, extended_image, shadow_angle):
        """
        Removes the extra bottom rows that were added by 'extend_height', 
        computed from the same shadow_angle that was used to extend the image.

        Parameters:
            extended_image (np.ndarray): The extended equirectangular image.
            shadow_angle (float): Additional field of view in degrees that was used to extend.

        Returns:
            np.ndarray: The image with the extended part removed.
        """
        cls.logger.info("Attempting to remove extension based on shadow_angle=%.2f", shadow_angle)

        if not isinstance(extended_image, np.ndarray):
            cls.logger.error("Image is not a valid numpy array.")
            raise TypeError("extended_image must be a numpy array.")

        shadow_angle = np.abs(shadow_angle)

        # We need to reverse the logic used in extend_height.
        # In extend_height, new_height = original_height + h_prime,
        # where h_prime = int((shadow_angle / 180.0) * original_height).
        # Thus extended_height = original_height + h_prime
        # => original_height ≈ extended_height / (1 + shadow_angle/180.0).
        
        fov_original = 180.0
        ext_height, ext_width, ext_channels = extended_image.shape
        
        # Estimate the original height (may be off-by-one due to integer rounding)
        estimated_original_height = int(
            round(ext_height / (1.0 + shadow_angle / fov_original))
        )
        
        # h_prime is then the difference
        h_prime_est = ext_height - estimated_original_height

        cls.logger.debug(
            "Extended image height: %d, Estimated original height: %d, "
            "Estimated h_prime: %d", ext_height, estimated_original_height, h_prime_est
        )

        if h_prime_est <= 0:
            cls.logger.warning(
                "Computed extension (%d) is <= 0. Possibly shadow_angle was never used to extend. "
                "Returning the input image.", h_prime_est
            )
            return extended_image

        # Slice the image to remove the bottom h_prime_est rows
        restored_image = extended_image[:estimated_original_height, :, :]

        cls.logger.info(
            "Extended rows removed. New height: %d", restored_image.shape[0]
        )
        return restored_image

    @classmethod
    def rotate(cls, image, delta_lat, delta_lon):
        """
        Rotates an equirectangular image based on latitude (delta_lat) and longitude (delta_lon) shifts.

        Parameters:
            image (np.ndarray): Input equirectangular image.
            delta_lat (float): Latitude rotation in degrees.
            delta_lon (float): Longitude rotation in degrees.

        Returns:
            np.ndarray: Rotated equirectangular image.
        """
        cls.logger.info("Starting rotation with delta_lat=%.2f, delta_lon=%.2f", delta_lat, delta_lon)
     
        if len(image.shape) == 2:
            H, W = image.shape
            C = 1
        else:
            H, W, C = image.shape
        cls.logger.debug("Image dimensions: Height=%d, Width=%d, Channels=%d", H, W, C)

        x = np.linspace(0, W - 1, W)
        y = np.linspace(0, H - 1, H)
        xv, yv = np.meshgrid(x, y)

        lon = (xv / (W - 1)) * 360.0 - 180.0
        lat = 90.0 - (yv / (H - 1)) * 180.0

        lat_rad = np.radians(lat)
        lon_rad = np.radians(lon)
        x_sphere = np.cos(lat_rad) * np.cos(lon_rad)
        y_sphere = np.cos(lat_rad) * np.sin(lon_rad)
        z_sphere = np.sin(lat_rad)

        delta_lat_rad = np.radians(delta_lat)
        delta_lon_rad = np.radians(delta_lon)

        # Rotate around the X-axis (latitude shift)
        x_rot = x_sphere
        y_rot = y_sphere * np.cos(delta_lat_rad) - z_sphere * np.sin(delta_lat_rad)
        z_rot = y_sphere * np.sin(delta_lat_rad) + z_sphere * np.cos(delta_lat_rad)

        # Rotate around the Z-axis (longitude shift)
        x_final = x_rot * np.cos(delta_lon_rad) - y_rot * np.sin(delta_lon_rad)
        y_final = x_rot * np.sin(delta_lon_rad) + y_rot * np.cos(delta_lon_rad)
        z_final = z_rot

        lon_final = np.arctan2(y_final, x_final)
        lat_final = np.arcsin(z_final)

        lon_final_deg = np.degrees(lon_final)
        lat_final_deg = np.degrees(lat_final)

        x_rot_map = ((lon_final_deg + 180.0) / 360.0) * (W - 1)
        y_rot_map = ((90.0 - lat_final_deg) / 180.0) * (H - 1)

        map_x = x_rot_map.astype(np.float32)
        map_y = y_rot_map.astype(np.float32)

        rotated_image = cv2.remap(
            image,
            map_x,
            map_y,
            interpolation=cv2.INTER_LINEAR,
            borderMode=cv2.BORDER_WRAP
        )

        cls.logger.info("Rotation complete.")
        return rotated_image

    @classmethod
    def preprocess(cls, image, **kwargs):
        """
        Preprocess an equirectangular image by optionally extending its height and then rotating it.

        Parameters:
            image (np.ndarray): Input equirectangular image.
            **kwargs: Parameters for preprocessing:
                - shadow_angle (float): Additional field of view in degrees to extend. Default is 0.
                - delta_lat (float): Latitude rotation in degrees. Default is 0.
                - delta_lon (float): Longitude rotation in degrees. Default is 0.

        Returns:
            processed_image (np.ndarray): Preprocessed (extended + rotated) image.
            h_prime (int): Number of rows added during extension.
        """
        shadow_angle = kwargs.get("shadow_angle", 0)
        delta_lat = kwargs.get("delta_lat", 0)
        delta_lon = kwargs.get("delta_lon", 0)

        cls.logger.info(
            "Starting preprocessing with parameters: shadow_angle=%.2f, delta_lat=%.2f, delta_lon=%.2f",
            shadow_angle, delta_lat, delta_lon
        )

        # Step 1: Extend the image height
        processed_image = cls.extend_height(image, shadow_angle) if shadow_angle >= 0 else cls.undo_extend_height(image, shadow_angle)
        
        # Step 2: Rotate the image
        processed_image = cls.rotate(processed_image, delta_lat, delta_lon)
        if len(processed_image.shape)==2:
            processed_image = processed_image[:, :, None]

        cls.logger.info("Preprocessing complete.")
        return processed_image

    @classmethod
    def save_image(cls, image, file_path):
        """
        Saves the current image to the specified file path.

        Parameters:
            image (np.ndarray): Image to save.
            file_path (str): Path to which the image should be saved.
        """
        if not isinstance(image, np.ndarray):
            cls.logger.error("Image is not a valid numpy array.")
            raise TypeError("Image must be a numpy array.")
        cv2.imwrite(file_path, image)
        cls.logger.info("Image saved to %s", file_path)


### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/pipeline/utils/resizer.py ###
from skimage.transform import resize
import logging
import sys
import cv2
# Logging setup for Jupyter notebooks
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
stream_handler = logging.StreamHandler(sys.stdout)
stream_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
logger.handlers = [stream_handler]

class ImageResizer:
    """Handles image resizing with explicit configuration."""

    def __init__(self, resize_factor=1.0, method="skimage", mode="reflect", anti_aliasing=True, interpolation=cv2.INTER_LINEAR):
        """
        Initialize the ImageResizer with explicit attributes.

        :param resize_factor: Factor by which to resize the image. >1 for upsampling, <1 for downsampling.
        :param method: Resizing method ('skimage' or 'cv2'). Default is 'skimage'.
        :param mode: The mode parameter for the skimage resize function. Default is "reflect".
        :param anti_aliasing: Whether to apply anti-aliasing during resizing (only for skimage). Default is True.
        :param interpolation: Interpolation method for cv2.resize. Default is cv2.INTER_LINEAR.
        """
        self.resize_factor = resize_factor
        self.method = method
        self.mode = mode
        self.anti_aliasing = anti_aliasing
        self.interpolation = interpolation

        logger.info(f"Initialized ImageResizer with resize_factor={resize_factor}, method={method}, "
                    f"mode={mode}, anti_aliasing={anti_aliasing}, interpolation={interpolation}")

    def resize_image(self, img, upsample=True):
        """
        Resize the input image based on the configuration.

        :param img: Input image as a NumPy array.
        :param upsample: Whether to apply upsampling or downsampling.
        :return: Resized image.
        """
        resize_factor = self.resize_factor
        if not upsample:
            resize_factor = 1 / resize_factor

        if resize_factor != 1.0:
            new_shape = (
                int(img.shape[0] * resize_factor),
                int(img.shape[1] * resize_factor),
            )
            logger.info(f"Resizing image with resize_factor={resize_factor}.")
            logger.debug(f"Original shape: {img.shape}, New shape: {new_shape}.")

            if self.method == "skimage":
                if len(img.shape) == 3:  # RGB image
                    resized_img = resize(
                        img, (*new_shape, img.shape[2]),
                        mode=self.mode,
                        anti_aliasing=self.anti_aliasing
                    )
                else:  # Grayscale image
                    resized_img = resize(
                        img, new_shape,
                        mode=self.mode,
                        anti_aliasing=self.anti_aliasing
                    )
                logger.info("Image resizing completed using skimage.")
            elif self.method == "cv2":
                resized_img = cv2.resize(
                    img, (new_shape[1], new_shape[0]),  # cv2 expects (width, height)
                    interpolation=self.interpolation
                )
                logger.info("Image resizing completed using cv2.")
            else:
                raise ValueError(f"Unknown resizing method: {self.method}")

            return resized_img

        logger.debug("No resizing applied; resize_factor is 1.0.")
        return img
    
class ResizerConfig:
    """Configuration for the resizer."""

    def __init__(self, resizer_cls=ImageResizer, resize_factor=1.0, method="skimage", mode="reflect", anti_aliasing=True, interpolation=cv2.INTER_LINEAR):
        """
        Initialize resizer configuration.

        :param resize_factor: Factor by which to resize the image. >1 for upsampling, <1 for downsampling.
        :param method: Resizing method ('skimage' or 'cv2'). Default is 'skimage'.
        :param mode: The mode parameter for the skimage resize function. Default is "reflect".
        :param anti_aliasing: Whether to apply anti-aliasing during resizing (only for skimage). Default is True.
        :param interpolation: Interpolation method for cv2.resize. Default is cv2.INTER_LINEAR.
        """
        self.resize_factor = resize_factor
        self.method = method
        self.mode = mode
        self.anti_aliasing = anti_aliasing
        self.interpolation = interpolation
        self.resizer_cls = resizer_cls

    def __repr__(self):
        return (f"ResizerConfig(resize_factor={self.resize_factor}, method='{self.method}', "
                f"mode='{self.mode}', anti_aliasing={self.anti_aliasing}, interpolation={self.interpolation})")

    def create_resizer(self):
        return self.resizer_cls(
            resize_factor=self.resize_factor,
            method=self.method,
            mode=self.mode,
            anti_aliasing=self.anti_aliasing,
            interpolation=self.interpolation
        )


### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/projection_deprecated/__init__.py ###
# projection/__init__.py

from .projector import ProjectorConfig, GnomonicProjector
from .utils.remapper import RemapConfig
from .utils.unsharp import UnsharpMaskConfig

__all__ = ["ProjectorConfig", "GnomonicProjector", "RemapConfig", "UnsharpMaskConfig"]

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/projection_deprecated/projector.py ###
import math
import numpy as np
from scipy import ndimage
import cv2
import logging
import os
import sys

from .utils.remapper import RemapConfig  # <-- import the RemapConfig (and Remapper if needed)
from .utils.unsharp import UnsharpMaskConfig


# Configure logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG if os.environ.get('DEBUG', 'False').lower() in ('true', '1') else logging.INFO)
handler = logging.StreamHandler(sys.stdout)
handler.setLevel(logger.level)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
logger.handlers = [handler]


def deg_to_rad(degrees: float) -> float:
    """Convert degrees to radians."""
    return degrees * math.pi / 180.0

def rad_to_deg(radians: float) -> float:
    """Convert radians to degrees."""
    return radians * 180.0 / math.pi


class ProjectionStrategy:
    """Abstract base class for projection strategies."""
    def forward(self, img: np.ndarray, lat_center: float, lon_center: float, fov: tuple) -> np.ndarray:
        raise NotImplementedError("Forward projection method must be implemented.")

    def backward(self, rect_img: np.ndarray, img_shape: tuple, lat_center: float, lon_center: float, fov: tuple) -> np.ndarray:
        raise NotImplementedError("Backward projection method must be implemented.")


class GnomonicProjector(ProjectionStrategy):
    """Gnomonic projection implementation."""

    def __init__(
        self, 
        dims: tuple[int, int], 
        shadow_angle_deg: float, 
        unsharp_fn=None,
        remap_config=None
    ):
        """
        Initialize the GnomonicProjector.

        :param dims: Dimensions of the output image (H, W).
        :param shadow_angle_deg: Shadow angle in degrees.
        :param order: The order of spline interpolation. Default is 3.
        :param prefilter: Whether to apply a prefilter (ndimage). Default is True.
        :param mode: Points outside boundaries handling mode (ndimage). Default is "nearest".
        :param unsharp_fn: A function that performs unsharp masking. Default is None.
        :param remap_config: A RemapConfig object that configures 'cv2' or 'ndimage' remapping.
        """
        self.dims = dims
        self.shadow_angle_deg = shadow_angle_deg
        self.unsharp_fn = unsharp_fn if unsharp_fn is not None else (lambda x: x)

        # Create or store a Remapper based on configuration
        if remap_config is None:
            # Default to cv2 approach with cubic interpolation
            remap_config = RemapConfig(
                method="cv2",
                interpolation=cv2.INTER_CUBIC,
                border_mode=cv2.BORDER_WRAP
            )
        self.remapper = remap_config.create_remapper()

        logger.info("Initialized GnomonicProjector with parameters:")
        logger.info(f"  dims: {self.dims}")
        logger.info(f"  shadow_angle_deg: {self.shadow_angle_deg}")
        logger.info(f"  unsharp_fn: {self.unsharp_fn}")
        logger.info(f"  remap_config: {remap_config}")


    def point_forward(self, x: np.ndarray, y: np.ndarray, phi1: float, lamb0: float) -> tuple[np.ndarray, np.ndarray]:
        """Convert x, y coordinates to phi, lamb for forward projection."""
        logger.debug("Running point_forward projection...")
        rho = np.sqrt(x**2 + y**2)
        c = np.arctan2(rho, 1.0)
        sinc = np.sin(c)
        cosc = np.cos(c)

        phi = np.arcsin(cosc * np.sin(phi1) + (y * sinc * np.cos(phi1) / (rho + 1e-9)))
        lamb = lamb0 + np.arctan2(x * sinc, (rho * np.cos(phi1) * cosc - y * sinc * np.sin(phi1) + 1e-9))

        # Clip / wrap results
        phi = np.clip(phi, -np.pi/2, np.pi/2)
        lamb = (lamb + np.pi) % (2 * np.pi) - np.pi
        return phi, lamb


    def point_backward(self, phi: np.ndarray, lamb: np.ndarray, phi1: float, lamb0: float, fov: tuple[float, float]) -> tuple[np.ndarray, np.ndarray]:
        """Convert phi, lamb coordinates to x, y for backward projection."""
        logger.debug("Running point_backward projection...")
        fov_h, fov_w = fov
        cosc = np.sin(phi1) * np.sin(phi) + np.cos(phi1) * np.cos(phi) * np.cos(lamb - lamb0)

        # Avoid division by zero
        cosc = np.maximum(cosc, 1e-10)

        x = (np.cos(phi) * np.sin(lamb - lamb0)) / (cosc * fov_w)
        y = (np.cos(phi1) * np.sin(phi) - np.sin(phi1) * np.cos(phi) * np.cos(lamb - lamb0)) / (cosc * fov_h)

        return x, y


    def forward(self, img: np.ndarray, lat_center: float, lon_center: float, fov: tuple[float, float]) -> np.ndarray:
        """Forward projection from equirectangular to rectilinear."""
        logger.info("Starting forward projection...")
        logger.debug(f"  Image shape: {img.shape}")
        logger.debug(f"  Lat center: {lat_center}, Lon center: {lon_center}, FOV: {fov}")

        # Ensure 3 channels
        if img.ndim == 2:
            img = np.stack([img, img, img], axis=-1)

        H, W = self.dims
        fov_h, fov_w = fov

        # Generate rectilinear grid
        x, y = np.meshgrid(
            np.linspace(-1, 1, W)*fov_w,
            np.linspace(-1, 1 , H)*fov_h
        )

        # Convert to spherical coordinates
        phi, lamb = self.point_forward(x, y, lat_center, lon_center)
        out_range_mask = (rad_to_deg(phi) >= (90 - self.shadow_angle_deg)) & (rad_to_deg(phi) <= 90) #=====> Understand why lat is in range -90 to 90


        # Scale to original image's coordinate system
        HH, WW, _ = img.shape
        # Vertical coordinate: map phi in range [-pi/2, pi/2] to [0, HH-1], also factoring shadow_angle_deg
        logger.debug(f"  Phi max: {phi.max()}, Phi min: {phi.min()}")
        phi = (phi / (np.pi/2) + 1) * 0.5 * (HH - 1) * (180 / (180 - self.shadow_angle_deg))
        logger.debug(f"  v max: {phi.max()}, v min: {phi.min()}")
        # Horizontal coordinate: lamb in range [-pi, pi] to [0, WW-1]
        lamb = (lamb / np.pi + 1) * 0.5 * (WW - 1) 

        # Use Remapper to do the actual pixel mapping
        rect_img = self.remapper.remap_image(img, phi, lamb)
        rect_img[out_range_mask] = 0.0


        # Apply optional unsharp mask
        return self.unsharp_fn(rect_img)


    def backward(self, rect_img: np.ndarray, img_shape: tuple, lat_center: float, lon_center: float, fov: tuple[float, float], return_mask: bool =False) -> np.ndarray:
        """Backward projection from rectilinear to equirectangular."""
        logger.info("Starting backward projection...")
        logger.debug(f"  Rectilinear image shape: {rect_img.shape}")
        logger.debug(f"  Target image shape: {img_shape}")
        logger.debug(f"  Lat center: {lat_center}, Lon center: {lon_center}, FOV: {fov}")
        H, W, _ = img_shape

        # Generate the equirectangular grid
        u, v = np.meshgrid(
            np.linspace(-1, 1, W),
            np.linspace(-1, (90 - self.shadow_angle_deg) / 90, H)
        )
        phi = v * (np.pi / 2)
        lamb = u * np.pi

        # Convert to rectilinear coordinates
        cosc = np.sin(lat_center) * np.sin(phi) + np.cos(lat_center) * np.cos(phi) * np.cos(lamb - lon_center)

        # Apply a mask: valid only where cosc >= 0
        valid_mask = cosc >= 0
        x, y = self.point_backward(phi, lamb, lat_center, lon_center, fov)

        # Scale to image coordinates
        x = (x + 1) * 0.5 * (rect_img.shape[1] - 1)
        y = (y + 1) * 0.5 * (rect_img.shape[0] - 1)
        
        # Create a mask for x,y that lie inside the image boundaries
        in_range_mask = (
            (x >= 0) & (x < rect_img.shape[1]) &
            (y >= 0) & (y < rect_img.shape[0])
        )

        # Combine the geometry valid_mask with the in_range_mask
        final_mask = valid_mask & in_range_mask

        # Remap from rect_img back to equirectangular
        back_img = self.remapper.remap_image(rect_img, y, x)

        # Apply valid_mask
        for c in range(back_img.shape[2]):
            channel = back_img[..., c]
            channel[~final_mask] = 0
            back_img[..., c] = channel

        if return_mask:
            return back_img, final_mask
        return back_img

 


logger = logging.getLogger(__name__)

# Suppose GnomonicProjector is already imported somewhere above
# from gnomonic_projector import GnomonicProjector

# Available projector classes
PROJECTOR_CLASSES = {
    "GnomonicProjector": GnomonicProjector,
    # Add other projector classes here if needed
}

class ProjectorConfig:
    """Configuration for the projector."""

    def __init__(
            self, 
            dims, 
            shadow_angle_deg, 
            projector_cls="GnomonicProjector", 
            unsharp=False, 
            unsharp_cfg=None,
            remap_cfg=None,
            **projector_kwargs
    ):
        """
        Initialize projector configuration.

        :param dims: Tuple (height, width) for projection dimensions.
        :param shadow_angle_deg: Shadow angle for the projector.
        :param projector_cls: Projector class to be instantiated (can be a string or class).
        :param unsharp: Boolean that controls whether to apply unsharp masking.
        :param unsharp_cfg: An UnsharpMaskConfig instance (optional). If provided, overrides the default unsharp config.
        :param remap_config: A RemapConfig instance (optional). If provided, projector uses its remapper. 
        :param projector_kwargs: Additional keyword arguments for the projector.
        """
        self.dims = dims
        self.shadow_angle_deg = shadow_angle_deg
        self.unsharp = unsharp

        # Set up unsharp configuration
        if self.unsharp and unsharp_cfg:
            self.unsharp_cfg = unsharp_cfg or UnsharpMaskConfig(sigma=2.0, kernel_size=7, strength=3.5)
            masker = self.unsharp_cfg.create_masker()
            self.unsharp_fn = masker.apply_unsharp_mask
        else:
            self.unsharp_fn = lambda x: x
            self.unsharp_cfg = None

        # Set up remap configuration
        # Default to a CV2-based remapping with cubic interpolation and BORDER_WRAP
        self.remap_config = remap_cfg or RemapConfig(method="cv2")


        # Validate or set projector class
        if isinstance(projector_cls, str):
            if projector_cls not in PROJECTOR_CLASSES:
                raise ValueError(f"Unknown projector class name: {projector_cls}")
            self.projector_cls = PROJECTOR_CLASSES[projector_cls]
        else:
            self.projector_cls = projector_cls
        
        self.projector_kwargs = projector_kwargs

        logger.info("Initialized ProjectorConfig with parameters:")
        logger.info(f"  dims: {self.dims}")
        logger.info(f"  shadow_angle_deg: {self.shadow_angle_deg}")
        logger.info(f"  projector_cls: {self.projector_cls}")
        logger.info(f"  unsharp: {self.unsharp}")
        logger.info(f"  unsharp_cfg: {self.unsharp_cfg if unsharp_cfg else None}")
        logger.info(f"  remap_config: {self.remap_config}")

    def create_projector(self):
        """
        Instantiate the projector with the configuration.
        Attach the unsharp masking function so the projector can call it if needed,
        along with a remap_config that the projector can use to initialize a Remapper.
        """
        projector_instance = self.projector_cls(
            dims=self.dims,
            shadow_angle_deg=self.shadow_angle_deg,
            unsharp_fn=self.unsharp_fn, 
            remap_config=self.remap_config,  # <-- pass the remap config here
            **self.projector_kwargs
        )
        return projector_instance

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/projection_deprecated/projector_deprecated.py ###
import math
import numpy as np
from scipy import ndimage
import cv2
from unsharp import UnsharpMaskConfig

def deg_to_rad(degrees: float) -> float:
    """Convert degrees to radians."""
    return degrees * math.pi / 180.0


def rad_to_deg(radians: float) -> float:
    """Convert radians to degrees."""
    return radians * 180.0 / math.pi

import numpy as np
from scipy import ndimage


class ProjectionStrategy:
    """Abstract base class for projection strategies."""

    def forward(self, img: np.ndarray, lat_center: float, lon_center: float, fov: tuple) -> np.ndarray:
        raise NotImplementedError("Forward projection method must be implemented.")

    def backward(self, rect_img: np.ndarray, img_shape: tuple, lat_center: float, lon_center: float, fov: tuple) -> np.ndarray:
        raise NotImplementedError("Backward projection method must be implemented.")

import logging
import os
import sys
import numpy as np
from scipy import ndimage

# Configure logging for Jupyter notebooks
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG if os.environ.get('DEBUG', 'False').lower() in ('true', '1') else logging.INFO)

# StreamHandler for Jupyter notebook output
handler = logging.StreamHandler(sys.stdout)
handler.setLevel(logger.level)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
logger.handlers = [handler]  # Replace other handlers with the notebook handler


class GnomonicProjector(ProjectionStrategy):
    """Gnomonic projection implementation."""

    def __init__(self, dims: tuple[int, int], shadow_angle_deg: float, order: int = 3, 
                 prefilter: bool = True, mode: str = "nearest", unsharp_fn=None):
        """
        Initialize the GnomonicProjector.

        Args:
            dims (tuple[int, int]): Dimensions of the output image (H, W).
            shadow_angle_deg (float): Shadow angle in degrees.
            order (int, optional): The order of the spline interpolation. Default is 3.
            prefilter (bool, optional): Whether to apply a prefilter before interpolation. Default is True.
            mode (str, optional): Points outside boundaries handling mode. Default is "nearest".
            unsharp (bool, optional): Whether to unsharp rectilinear projections. Default is True.
        """
        self.dims = dims
        self.shadow_angle_deg = shadow_angle_deg
        self.order = order
        self.prefilter = prefilter
        self.mode = mode
        self.unsharp_fn = unsharp_fn  # Store the unsharp masking function
        

        # Log initialization parameters
        logger.info("Initialized GnomonicProjector with parameters:")
        logger.info(f"  dims: {self.dims}")
        logger.info(f"  shadow_angle_deg: {self.shadow_angle_deg}")
        logger.info(f"  order: {self.order}")
        logger.info(f"  prefilter: {self.prefilter}")
        logger.info(f"  mode: {self.mode}")
        logger.info(f"  unsharp_fn: {self.unsharp_fn}")
        

    def point_forward(self, x: np.ndarray, y: np.ndarray, phi1: float, lamb0: float) -> tuple[np.ndarray, np.ndarray]:
        """Convert x, y coordinates to phi, lamb for forward projection."""
        logger.debug("Running point_forward projection...")
        rho = np.sqrt(x**2 + y**2)
        c = np.arctan2(rho, 1)
        sinc = np.sin(c)
        cosc = np.cos(c)

        phi = np.arcsin(cosc * np.sin(phi1) + (y * sinc * np.cos(phi1) / rho))
        lamb = lamb0 + np.arctan2(x * sinc, rho * np.cos(phi1) * cosc - y * sinc * np.sin(phi1))

        # Handle out-of-range values
        phi = np.clip(phi, -np.pi / 2, np.pi / 2)
        lamb = (lamb + np.pi) % (2 * np.pi) - np.pi
        return phi, lamb

    def point_backward(self, phi: np.ndarray, lamb: np.ndarray, phi1: float, lamb0: float, fov: tuple[float, float]) -> tuple[np.ndarray, np.ndarray]:
        """Convert phi, lamb coordinates to x, y for backward projection."""
        logger.debug("Running point_backward projection...")
        fov_h, fov_w = fov
        cosc = np.sin(phi1) * np.sin(phi) + np.cos(phi1) * np.cos(phi) * np.cos(lamb - lamb0)

        # Avoid division by zero
        cosc = np.maximum(cosc, 1e-10)

        x = (np.cos(phi) * np.sin(lamb - lamb0)) / (cosc * fov_w)
        y = (np.cos(phi1) * np.sin(phi) - np.sin(phi1) * np.cos(phi) * np.cos(lamb - lamb0)) / (cosc * fov_h)

        return x, y

    def forward(self, img: np.ndarray, lat_center: float, lon_center: float, fov: tuple[float, float]) -> np.ndarray:
        """Forward projection from equirectangular to rectilinear."""
        logger.info("Starting forward projection...")
        logger.debug(f"  Image shape: {img.shape}")
        logger.debug(f"  Lat center: {lat_center}, Lon center: {lon_center}, FOV: {fov}")
        if len(img.shape) == 2:
            img = np.stack([img, img, img], axis=-1)

        H, W = self.dims
        fov_h, fov_w = fov

        # Generate the rectilinear grid
        x, y = np.meshgrid(
            np.linspace(-1, 1, W) * fov_w,
            np.linspace(-1, 1, H) * fov_h
        )

        # Convert to spherical coordinates
        phi, lamb = self.point_forward(x, y, lat_center, lon_center)

        # Scale to image coordinates
        HH, WW, C = img.shape
        phi = (phi / (np.pi / 2) + 1) * 0.5 * (HH - 1) * (180 / (180 - self.shadow_angle_deg))
        lamb = (lamb / np.pi + 1) * 0.5 * (WW - 1)

        # Interpolate pixel values
        """
        rect_img = np.stack([
            ndimage.map_coordinates(
                img[:, :, i],
                [phi, lamb],
                order=self.order,
                prefilter=self.prefilter,
                mode=self.mode
            ) for i in range(C)
        ], axis=-1)
        """

        map_x = lamb.astype(np.float32)
        map_y = phi.astype(np.float32)

        rect_img = cv2.remap(img, map_x, map_y, interpolation=cv2.INTER_CUBIC, borderMode=cv2.BORDER_WRAP)


        return self.unsharp_fn(rect_img)

    def backward(self, rect_img: np.ndarray, img_shape: tuple, lat_center: float, lon_center: float, fov: tuple[float, float]) -> np.ndarray:
        """Backward projection from rectilinear to equirectangular."""
        logger.info("Starting backward projection...")
        logger.debug(f"  Rectilinear image shape: {rect_img.shape}")
        logger.debug(f"  Target image shape: {img_shape}")
        logger.debug(f"  Lat center: {lat_center}, Lon center: {lon_center}, FOV: {fov}")
        H, W, _ = img_shape
        fov_h, fov_w = fov

        # Generate the equirectangular grid
        u, v = np.meshgrid(
            np.linspace(-1, 1, W),
            np.linspace(-1, (90 - self.shadow_angle_deg) / 90, H)
        )
        phi = v * (np.pi / 2)
        lamb = u * np.pi

        # Convert to rectilinear coordinates
        cosc = np.sin(lat_center) * np.sin(phi) + np.cos(lat_center) * np.cos(phi) * np.cos(lamb - lon_center)

        # Apply a mask: valid only where cosc >= 0
        valid_mask = cosc >= 0
        x, y = self.point_backward(phi, lamb, lat_center, lon_center, fov)

        # Scale to image coordinates
        x = (x + 1) * 0.5 * (rect_img.shape[1] - 1)
        y = (y + 1) * 0.5 * (rect_img.shape[0] - 1)

        # Interpolate pixel values, applying the valid mask
        equirect_img = np.stack([
            ndimage.map_coordinates(
                rect_img[:, :, i],
                [y.ravel(), x.ravel()],
                order=self.order,
                prefilter=self.prefilter
            ).reshape(H, W) * valid_mask for i in range(rect_img.shape[2])
        ], axis=-1)

        return equirect_img



# Available projector and sampler classes
PROJECTOR_CLASSES = {
    "GnomonicProjector": GnomonicProjector,
    # Add other projector classes here if needed
}

class ProjectorConfig:
    """Configuration for the projector."""

    def __init__(
            self, 
            dims, 
            shadow_angle_deg, 
            projector_cls="GnomonicProjector", 
            order=3, 
            prefilter=True, 
            mode="nearest", 
            unsharp=False, 
            unsharp_cfg=None, 
            **projector_kwargs):
        """
        Initialize projector configuration.

        :param dims: Tuple (height, width) for projection dimensions.
        :param shadow_angle_deg: Shadow angle for the projector.
        :param projector_cls: Projector class to be instantiated (can be a string or class).
        :param order: The order of spline interpolation for the projector. Default is 3.
        :param prefilter: Whether to apply a prefilter before interpolation. Default is True.
        :param mode: Points outside boundaries handling mode. Default is "nearest".
        :param unsharp: Boolean that controls whether to apply unsharp masking.
        :param unsharp_cfg: An UnsharpMaskConfig instance (optional). If provided, overrides the default unsharp config.
        :param projector_kwargs: Additional keyword arguments for the projector.
        """
        self.dims = dims
        self.shadow_angle_deg = shadow_angle_deg
        self.order = order
        self.prefilter = prefilter
        self.mode = mode
        self.unsharp = unsharp

        # Set up unsharp configuration
        if self.unsharp or unsharp_cfg:
            self.unsharp_cfg = unsharp_cfg or UnsharpMaskConfig(sigma=2.0, kernel_size=7, strength=3.5)
            masker = self.unsharp_cfg.create_masker()
            self.unsharp_fn = masker.apply_unsharp_mask
        else:
            self.unsharp_fn = lambda x:x

        if isinstance(projector_cls, str):
            if projector_cls not in PROJECTOR_CLASSES:
                raise ValueError(f"Unknown projector class name: {projector_cls}")
            self.projector_cls = PROJECTOR_CLASSES[projector_cls]
        else:
            self.projector_cls = projector_cls
        
        self.projector_kwargs = projector_kwargs

    def create_projector(self):
        """
        Instantiate the projector with the configuration.
        Attach the unsharp masking function so the projector can call it if needed.
        """
        projector_instance = self.projector_cls(
            dims=self.dims,
            shadow_angle_deg=self.shadow_angle_deg,
            order=self.order,
            prefilter=self.prefilter,
            mode=self.mode,
            unsharp_fn=self.unsharp_fn,  # <-- pass the unsharp function here
            **self.projector_kwargs
        )
        return projector_instance














class __GnomonicProjector(ProjectionStrategy):
    """Gnomonic projection implementation."""

    def __init__(self, dims: tuple[int, int], shadow_angle_deg: float, order: int = 3, prefilter: bool = True, mode: str = "nearest"):
        """
        Initialize the GnomonicProjector.

        Args:
            dims (tuple[int, int]): Dimensions of the output image (H, W).
            shadow_angle_deg (float): Shadow angle in degrees.
            order (int, optional): The order of the spline interpolation. Default is 3.
            prefilter (bool, optional): Whether to apply a prefilter before interpolation. Default is True.
            mode (str, optional): Points outside boundaries handling mode. Default is "nearest".
        """
        self.dims = dims
        self.shadow_angle_deg = shadow_angle_deg
        self.order = order
        self.prefilter = prefilter
        self.mode = mode

    def point_forward(self, x: np.ndarray, y: np.ndarray, phi1: float, lamb0: float) -> tuple[np.ndarray, np.ndarray]:
        """Convert x, y coordinates to phi, lamb for forward projection."""
        rho = np.sqrt(x**2 + y**2)
        c = np.arctan2(rho, 1)
        sinc = np.sin(c)
        cosc = np.cos(c)

        phi = np.arcsin(cosc * np.sin(phi1) + (y * sinc * np.cos(phi1) / rho))
        lamb = lamb0 + np.arctan2(x * sinc, rho * np.cos(phi1) * cosc - y * sinc * np.sin(phi1))

        # Handle out-of-range values
        phi = np.clip(phi, -np.pi / 2, np.pi / 2)
        lamb = (lamb + np.pi) % (2 * np.pi) - np.pi
        return phi, lamb

    def point_backward(self, phi: np.ndarray, lamb: np.ndarray, phi1: float, lamb0: float, fov: tuple[float, float]) -> tuple[np.ndarray, np.ndarray]:
        """Convert phi, lamb coordinates to x, y for backward projection."""
        fov_h, fov_w = fov
        cosc = np.sin(phi1) * np.sin(phi) + np.cos(phi1) * np.cos(phi) * np.cos(lamb - lamb0)

        # Avoid division by zero
        cosc = np.maximum(cosc, 1e-10)

        x = (np.cos(phi) * np.sin(lamb - lamb0)) / (cosc * fov_w)
        y = (np.cos(phi1) * np.sin(phi) - np.sin(phi1) * np.cos(phi) * np.cos(lamb - lamb0)) / (cosc * fov_h)

        return x, y

    def forward(self, img: np.ndarray, lat_center: float, lon_center: float, fov: tuple[float, float]) -> np.ndarray:
        """Forward projection from equirectangular to rectilinear."""
        if len(img.shape) == 2:
            img = np.stack([img, img, img], axis=-1)

        H, W = self.dims
        fov_h, fov_w = fov

        # Generate the rectilinear grid
        x, y = np.meshgrid(
            np.linspace(-1, 1, W) * fov_w,
            np.linspace(-1, 1, H) * fov_h
        )

        # Convert to spherical coordinates
        phi, lamb = self.point_forward(x, y, lat_center, lon_center)

        # Scale to image coordinates
        HH, WW, C = img.shape
        phi = (phi / (np.pi / 2) + 1) * 0.5 * (HH - 1) * (180 / (180 - self.shadow_angle_deg))
        lamb = (lamb / np.pi + 1) * 0.5 * (WW - 1)

        # Interpolate pixel values
        rect_img = np.stack([
            ndimage.map_coordinates(
                img[:, :, i],
                [phi, lamb],
                order=self.order,
                prefilter=self.prefilter,
                mode=self.mode
            ) for i in range(C)
        ], axis=-1)

        return rect_img

    def backward(self, rect_img: np.ndarray, img_shape: tuple, lat_center: float, lon_center: float, fov: tuple[float, float]) -> np.ndarray:
        """Backward projection from rectilinear to equirectangular."""
        H, W, _ = img_shape
        fov_h, fov_w = fov

        # Generate the equirectangular grid
        u, v = np.meshgrid(
            np.linspace(-1, 1, W),
            np.linspace(-1, (90 - self.shadow_angle_deg) / 90, H)
        )
        phi = v * (np.pi / 2)
        lamb = u * np.pi

        # Convert to rectilinear coordinates
        cosc = np.sin(lat_center) * np.sin(phi) + np.cos(lat_center) * np.cos(phi) * np.cos(lamb - lon_center)

        # Apply a mask: valid only where cosc >= 0
        valid_mask = cosc >= 0
        x, y = self.point_backward(phi, lamb, lat_center, lon_center, fov)

        # Scale to image coordinates
        x = (x + 1) * 0.5 * (rect_img.shape[1] - 1)
        y = (y + 1) * 0.5 * (rect_img.shape[0] - 1)

        # Interpolate pixel values, applying the valid mask
        equirect_img = np.stack([
            ndimage.map_coordinates(
                rect_img[:, :, i],
                [y.ravel(), x.ravel()],
                order=self.order,
                prefilter=self.prefilter
            ).reshape(H, W) * valid_mask for i in range(rect_img.shape[2])
        ], axis=-1)

        return equirect_img
    
class _GnomonicProjector(ProjectionStrategy):
    """Gnomonic projection implementation."""

    def __init__(self, dims: tuple[int, int], shadow_angle_deg: float):
        self.dims = dims
        self.shadow_angle_deg = shadow_angle_deg
        

    def point_forward(self, x: np.ndarray, y: np.ndarray, phi1: float, lamb0: float) -> tuple[np.ndarray, np.ndarray]:
        """Convert x, y coordinates to phi, lamb for forward projection."""
        rho = np.sqrt(x**2 + y**2)
        c = np.arctan2(rho, 1)
        sinc = np.sin(c)
        cosc = np.cos(c)

        phi = np.arcsin(cosc * np.sin(phi1) + (y * sinc * np.cos(phi1) / rho))
        lamb = lamb0 + np.arctan2(x * sinc, rho * np.cos(phi1) * cosc - y * sinc * np.sin(phi1))

        # Handle out-of-range values
        phi = np.clip(phi, -np.pi / 2, np.pi / 2)
        lamb = (lamb + np.pi) % (2 * np.pi) - np.pi
        return phi, lamb

    def point_backward(self, phi: np.ndarray, lamb: np.ndarray, phi1: float, lamb0: float, fov: tuple[float, float]) -> tuple[np.ndarray, np.ndarray]:
        """Convert phi, lamb coordinates to x, y for backward projection."""
        fov_h, fov_w = fov
        cosc = np.sin(phi1) * np.sin(phi) + np.cos(phi1) * np.cos(phi) * np.cos(lamb - lamb0)

        # Avoid division by zero
        cosc = np.maximum(cosc, 1e-10)

        x = (np.cos(phi) * np.sin(lamb - lamb0)) / (cosc * fov_w)
        y = (np.cos(phi1) * np.sin(phi) - np.sin(phi1) * np.cos(phi) * np.cos(lamb - lamb0)) / (cosc * fov_h)

        return x, y

    def forward(self, img: np.ndarray, lat_center: float, lon_center: float, fov: tuple[float, float]) -> np.ndarray:
        """Forward projection from equirectangular to rectilinear."""
        if len(img.shape) == 2:
            img = np.stack([img, img, img], axis=-1)

        H, W = self.dims
        fov_h, fov_w = fov

        # Generate the rectilinear grid
        x, y = np.meshgrid(
            np.linspace(-1, 1, W) * fov_w,
            np.linspace(-1, 1, H) * fov_h
        )

        # Convert to spherical coordinates
        phi, lamb = self.point_forward(x, y, lat_center, lon_center)

        # Scale to image coordinates
        HH, WW, C = img.shape
        phi = (phi / (np.pi / 2) + 1) * 0.5 * (HH - 1) * (180 / (180 - self.shadow_angle_deg))
        lamb = (lamb / np.pi + 1) * 0.5 * (WW - 1)

        # Interpolate pixel values
        rect_img = np.stack([
            ndimage.map_coordinates(img[:, :, i], [phi, lamb], order=3, prefilter=True, mode="mirror") for i in range(C)
        ], axis=-1)

        return rect_img
    def backward(self, rect_img: np.ndarray, img_shape: tuple, lat_center: float, lon_center: float, fov: tuple[float, float]) -> np.ndarray:
        """Backward projection from rectilinear to equirectangular."""
        H, W, _ = img_shape
        fov_h, fov_w = fov

        # Generate the equirectangular grid
        u, v = np.meshgrid(
            np.linspace(-1, 1, W),
            np.linspace(-1, (90 - self.shadow_angle_deg) / 90, H)
        )
        phi = v * (np.pi / 2)
        lamb = u * np.pi

        # Convert to rectilinear coordinates
        cosc = np.sin(lat_center) * np.sin(phi) + np.cos(lat_center) * np.cos(phi) * np.cos(lamb - lon_center)

        # Apply a mask: valid only where cosc >= 0
        valid_mask = cosc >= 0
        x, y = self.point_backward(phi, lamb, lat_center, lon_center, fov)

        # Scale to image coordinates
        x = (x + 1) * 0.5 * (rect_img.shape[1] - 1)
        y = (y + 1) * 0.5 * (rect_img.shape[0] - 1)

        # Interpolate pixel values, applying the valid mask
        equirect_img = np.stack([
            ndimage.map_coordinates(rect_img[:, :, i], [y.ravel(), x.ravel()], order=0, prefilter=True)
            .reshape(H, W) * valid_mask for i in range(rect_img.shape[2])
        ], axis=-1)

        return equirect_img
   
class good_old_GnomonicProjector:
    def __init__(self,dims,shadow_angle_deg):
        self.f_projection=None
        self.b_projection=None
        self.dims=dims
        self.scanner_shadow_angle=shadow_angle_deg
        pass
    
    def point_forward(self,x,y,phi1,lamb0,fov):
        rho=np.sqrt(x**2+y**2)
        c=np.arctan2(rho,1)
        sinc=np.sin(c)
        cosc=np.cos(c)

        phi=np.arcsin(cosc*np.sin(phi1)+(y*sinc*np.cos(phi1)/rho))
        lamb=lamb0+np.arctan2(x*sinc,rho*np.cos(phi1)*cosc-y*np.sin(phi1)*sinc)
        
        phi=np.where(phi<-np.pi/2,np.pi/2-phi,phi)
        lamb=np.where(lamb<-np.pi,2*np.pi+lamb,lamb)

        phi=np.where(phi>np.pi/2,-np.pi/2+phi,phi)
        lamb=np.where(lamb>np.pi,-2*np.pi+lamb,lamb)
        
        return phi,lamb
    

    def forward(self,img,phi1,lamb0,fov=(1,1)):
        
        if len(img.shape)==2:
            img = np.stack([img,img,img],axis=-1)
        
        fov_h, fov_w = fov
        
        H,W=self.dims
        
        x , y = np.meshgrid(np.linspace( -1, 1, W) * fov_w ,\
                            np.linspace( -1, 1 , H) * fov_h)
        
        phi, lamb = self.point_forward(x ,y ,phi1 , lamb0, fov)
        
        mask = ( phi > np.pi/3)&( phi < np.pi/2)
        
        phi = phi/(np.pi/2)
                  
        lamb =  lamb/np.pi

        HH,WW,C=img.shape

        phi=( 0.5* ( phi + 1) ) * ( HH - 1) * ( ( 180 / ( 180 - self.scanner_shadow_angle) ) )
        #phi = phi * (HH -1)
        
        
        lamb=( 0.5 * ( lamb + 1 ) ) * ( WW - 1 )

        o_img = [ ndimage.map_coordinates( img[:,:,i], np.stack([phi,lamb]), order=0, prefilter=True, mode="nearest") for i in range(C)]
        
        o_img = np.stack( o_img, axis=-1) # grid-wrap
        
        self.f_projection=o_img
        self.phi1=phi1
        self.lamb0=lamb0
        self.fov=fov
        return o_img
    
    def point_backward(self,phi,lamb,phi1,lamb0,fov):
        fov_h,fov_w = fov
        cosc=np.sin(phi1)*np.sin(phi)+np.cos(phi1)*np.cos(phi)*np.cos(lamb-lamb0)

        K=1/cosc
        x=K*np.cos(phi)*np.sin(lamb-lamb0)/fov_w
        y=K*(np.cos(phi1)*np.sin(phi)-np.sin(phi1)*np.cos(phi)*np.cos(lamb-lamb0))/fov_h
        
        x=0.5*(x+1)
        y=0.5*(y+1)

        HH, WW = self.dims
        
        x=x*(WW-1)
        y=y*(HH-1)
        self.cosc=cosc
        return x,y
    
    def backward(self,face,img_shape,phi1=None,lamb0=None,fov=None):

        #if len(img.shape)==2:
        #    img = np.stack([img,img,img],axis=-1)


        if len(face.shape)==2:
            face = np.stack([face,face,face],axis=-1)
            
        H,W,_= img_shape
  

        u , v=  np.meshgrid(
                    np.linspace(-1 , 1 , W), \
                    np.linspace( -1 ,\
                                ( (90 - self.scanner_shadow_angle) / 90) , \
                                H))

        #u , v=np.meshgrid(np.linspace(-1,1,W),np.linspace(-1,1,H))

        phi = v * (np.pi/2)
        lamb = u * np.pi
        
       
        x,y=self.point_backward(phi,lamb,phi1,lamb0,fov)

        coords = np.stack([x,y])


        oo=[ndimage.map_coordinates(face.T[i,:,:], coords,order=0, prefilter=True)*(self.cosc>=0) for i in range(3)]
        
        oo=np.stack(oo,axis=-1)
        self.b_projection=oo
        return oo

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/projection_deprecated/utils/__init__.py ###
# projection/utils/__init__.py

from .remapper import RemapConfig, Remapper
from .unsharp import UnsharpMaskConfig

__all__ = ["RemapConfig", "Remapper", "UnsharpMaskConfig"]

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/projection_deprecated/utils/remapper.py ###
# remapper.py

import numpy as np
import cv2
from scipy import ndimage
import logging
import sys

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
stream_handler = logging.StreamHandler(sys.stdout)
stream_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
logger.handlers = [stream_handler]

class Remapper:
    """
    Handles remapping using either scipy.ndimage or OpenCV.
    """

    def __init__(
        self,
        method="ndimage",
        order=3,
        prefilter=True,
        mode="nearest",
        interpolation=cv2.INTER_CUBIC,
        border_mode=cv2.BORDER_WRAP
    ):
        """
        :param method: The remapping method ('ndimage' or 'cv2'). Default is 'ndimage'.
        :param order: Spline interpolation order (for ndimage). Default is 3.
        :param prefilter: Prefilter option (for ndimage). Default is True.
        :param mode: Out-of-bounds mode (for ndimage). Default is 'nearest'.
        :param interpolation: Interpolation (for cv2). Default is cv2.INTER_CUBIC.
        :param border_mode: Border handling (for cv2). Default is cv2.BORDER_WRAP.
        """
        self.method = method
        self.order = order
        self.prefilter = prefilter
        self.mode = mode
        self.interpolation = interpolation
        self.border_mode = border_mode

        logger.info(f"Initialized Remapper with method={method}, order={order}, prefilter={prefilter}, "
                    f"mode={mode}, interpolation={interpolation}, border_mode={border_mode}")

    def remap_image(self, img, phi, lamb):
        """
        Remap the input image using either ndimage.map_coordinates or cv2.remap.

        :param img: Input image as a NumPy array (H, W, C).
        :param phi: Float array, same shape as output, specifying the "row" coordinates.
        :param lamb: Float array, same shape as output, specifying the "col" coordinates.
        :return: Remapped image as a NumPy array (same shape as phi,lamb + channels).
        """
        logger.debug(f"Starting remap with method={self.method}.")
        logger.debug(f"Image shape: {img.shape}, phi shape: {phi.shape}, lamb shape: {lamb.shape}")

        if self.method == "ndimage":
            # For an image with C channels
            if img.ndim == 2:
                # Grayscale single-channel
                remapped = ndimage.map_coordinates(
                    img,
                    [phi, lamb],
                    order=self.order,
                    prefilter=self.prefilter,
                    mode=self.mode
                )
            else:
                C = img.shape[2]
                remapped = np.stack([
                    ndimage.map_coordinates(
                        img[..., i],
                        [phi, lamb],
                        order=self.order,
                        prefilter=self.prefilter,
                        mode=self.mode
                    ) for i in range(C)
                ], axis=-1)

            logger.info("Remapping completed using ndimage.map_coordinates.")
            return remapped

        elif self.method == "cv2":
            # Convert to float32 for OpenCV
            map_x = lamb.astype(np.float32)
            map_y = phi.astype(np.float32)
            remapped = cv2.remap(
                img,
                map_x,
                map_y,
                interpolation=self.interpolation,
                borderMode=self.border_mode
            )
            logger.info("Remapping completed using cv2.remap.")
            return remapped

        else:
            raise ValueError(f"Unknown remapping method: {self.method}")


class RemapConfig:
    """
    Configuration for the Remapper.
    """

    def __init__(
        self,
        method="ndimage",
        order=3,
        prefilter=True,
        mode="nearest",
        interpolation=cv2.INTER_CUBIC,
        border_mode=cv2.BORDER_WRAP
    ):
        """
        :param method: 'ndimage' or 'cv2'.
        :param order: Spline interpolation order (ndimage).
        :param prefilter: Prefilter option (ndimage).
        :param mode: Out-of-bounds mode (ndimage).
        :param interpolation: Interpolation mode (cv2).
        :param border_mode: Border handling mode (cv2).
        """
        self.method = method
        self.order = order
        self.prefilter = prefilter
        self.mode = mode
        self.interpolation = interpolation
        self.border_mode = border_mode

    def __repr__(self):
        return (f"RemapConfig(method='{self.method}', order={self.order}, "
                f"prefilter={self.prefilter}, mode='{self.mode}', "
                f"interpolation={self.interpolation}, border_mode={self.border_mode})")

    def create_remapper(self):
        """
        Instantiate a Remapper with the stored config.
        """
        return Remapper(
            method=self.method,
            order=self.order,
            prefilter=self.prefilter,
            mode=self.mode,
            interpolation=self.interpolation,
            border_mode=self.border_mode
        )

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/projection_deprecated/utils/unsharp.py ###
import logging
import sys

# Logging setup for Jupyter notebooks (or standard Python scripts)
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
stream_handler = logging.StreamHandler(sys.stdout)
stream_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
logger.handlers = [stream_handler]

class UnsharpMasker:
    """
    Applies an unsharp mask operation to sharpen an image using Gaussian blur subtraction.
    """

    def __init__(self, sigma=1.0, kernel_size=7, strength=1.5):
        """
        Initialize the UnsharpMasker with explicit attributes.

        :param sigma: Standard deviation for Gaussian blur.
        :param kernel_size: Kernel size (must be an odd number) for Gaussian blur.
        :param strength: Strength of the sharpening. Higher values produce a stronger effect.
        """
        self.sigma = sigma
        self.kernel_size = kernel_size
        self.strength = strength

        logger.info(f"Initialized UnsharpMasker with sigma={sigma}, kernel_size={kernel_size}, strength={strength}")

    def apply_unsharp_mask(self, image):
        """
        Apply the unsharp mask to the input image.

        :param image: Input image as a NumPy array.
        :return: Sharpened image.
        """
        import cv2
        logger.debug("Starting unsharp masking process.")
        logger.debug(f"Applying GaussianBlur with kernel_size={self.kernel_size}, sigma={self.sigma}")

        blurred = cv2.GaussianBlur(image, (self.kernel_size, self.kernel_size), self.sigma)

        logger.debug(f"Combining original image with blurred image for sharpening with strength={self.strength}.")
        # unsharp_mask = original_image * (1 + strength) + blurred_image * (-strength)
        sharpened = cv2.addWeighted(image, 1.0 + self.strength, blurred, -self.strength, 0)

        logger.info("Unsharp mask applied successfully.")
        return sharpened


class UnsharpMaskConfig:
    """
    Configuration for the UnsharpMasker.
    """

    def __init__(self, masker_cls=UnsharpMasker, sigma=1.0, kernel_size=7, strength=1.5):
        """
        Initialize unsharp mask configuration.

        :param sigma: Standard deviation for Gaussian blur.
        :param kernel_size: Kernel size (must be an odd number) for Gaussian blur.
        :param strength: Strength of the sharpening. Higher values produce a stronger effect.
        :param masker_cls: The class to use for creating the unsharp masker.
        """
        self.sigma = sigma
        self.kernel_size = kernel_size
        self.strength = strength
        self.masker_cls = masker_cls

    def __repr__(self):
        return (f"UnsharpMaskConfig(sigma={self.sigma}, kernel_size={self.kernel_size}, "
                f"strength={self.strength})")

    def create_masker(self):
        """
        Create and return an instance of the unsharp masker class with the current config.
        """
        return self.masker_cls(
            sigma=self.sigma,
            kernel_size=self.kernel_size,
            strength=self.strength
        )

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/sampler/__init__.py ###
# sampler/__init__.py

from .sampler import SamplerConfig, CubeSampler, IcosahedronSampler, FibonacciSampler

__all__ = ["SamplerConfig", "CubeSampler", "IcosahedronSampler", "FibonacciSampler"]

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/sampler/sampler.py ###
from abc import ABC, abstractmethod
import numpy as np

class Sampler(ABC):
    """Abstract base class for sphere samplers."""
    @abstractmethod
    def get_tangent_points(self):
        """
        Generate tangent points (latitude, longitude) on the sphere.
        """
        pass


class CubeSampler(Sampler):
    """Generates tangent points for a cube-based projection."""
    def __init__(self, **kwargs):
        """
        Initialize the CubeSampler with optional parameters from kwargs.

        :param kwargs: Additional parameters (unused but accepted for compatibility).
        """
        pass  # CubeSampler doesn't require specific parameters.

    def get_tangent_points(self):
        """
        Returns tangent points for cube faces (latitude, longitude).
        """
        return [
            (0, 0),     # Front
            (0, 90),    # Right
            (0, 180),   # Back
            (0, -90),   # Left
            (90, 0),    # Top
            (-90, 0)    # Bottom
        ]


class IcosahedronSampler(Sampler):
    """Generates tangent points for an icosahedron-based projection."""
    def __init__(self, **kwargs):
        """
        Initialize the IcosahedronSampler with parameters from kwargs.

        :param kwargs: Additional parameters. Expected 'subdivisions' key for subdivisions.
        """
        self.subdivisions = kwargs.get('subdivisions', 0)  # Default to 0 subdivisions.
        self.vertices, self.faces = self._generate_icosahedron()

    def _generate_icosahedron(self):
        """
        Generate vertices and faces of the icosahedron with subdivisions.
        """
        phi = (1 + np.sqrt(5)) / 2  # Golden ratio
        verts = [
            [-1, phi, 0], [1, phi, 0], [-1, -phi, 0], [1, -phi, 0],
            [0, -1, phi], [0, 1, phi], [0, -1, -phi], [0, 1, -phi],
            [phi, 0, -1], [phi, 0, 1], [-phi, 0, -1], [-phi, 0, 1]
        ]
        verts = [self._normalize_vertex(*v) for v in verts]

        faces = [
            [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
            [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
            [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
            [5, 4, 9], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
        ]

        for _ in range(self.subdivisions):
            mid_cache = {}
            faces_subdiv = []
            for tri in faces:
                v1 = self._midpoint(verts, mid_cache, tri[0], tri[1])
                v2 = self._midpoint(verts, mid_cache, tri[1], tri[2])
                v3 = self._midpoint(verts, mid_cache, tri[2], tri[0])
                faces_subdiv.extend([
                    [tri[0], v1, v3],
                    [tri[1], v2, v1],
                    [tri[2], v3, v2],
                    [v1, v2, v3]
                ])
            faces = faces_subdiv

        return np.array(verts), faces

    @staticmethod
    def _normalize_vertex(x, y, z):
        """
        Normalize a vertex to the unit sphere.
        """
        length = np.sqrt(x**2 + y**2 + z**2)
        return [i / length for i in (x, y, z)]

    @staticmethod
    def _midpoint(verts, cache, p1, p2):
        """
        Find or create the midpoint between two vertices.
        """
        smaller, larger = sorted([p1, p2])
        key = (smaller, larger)
        if key in cache:
            return cache[key]

        v1 = verts[p1]
        v2 = verts[p2]
        mid = [(v1[i] + v2[i]) / 2 for i in range(3)]
        mid_normalized = IcosahedronSampler._normalize_vertex(*mid)
        verts.append(mid_normalized)
        cache[key] = len(verts) - 1
        return cache[key]

    def get_tangent_points(self):
        """
        Compute tangent points from the face centers.
        """
        face_centers = np.mean(self.vertices[np.array(self.faces)], axis=1)
        return [self._cartesian_to_lat_lon(center) for center in face_centers]

    @staticmethod
    def _cartesian_to_lat_lon(cartesian):
        """
        Convert Cartesian coordinates to latitude and longitude.
        """
        x, y, z = cartesian
        latitude = np.degrees(np.arcsin(z))
        longitude = np.degrees(np.arctan2(y, x))
        return latitude, longitude


class FibonacciSampler(Sampler):
    """Generates tangent points using the Fibonacci sphere method."""
    def __init__(self, **kwargs):
        """
        Initialize the FibonacciSampler with parameters from kwargs.

        :param kwargs: Additional parameters. Expected 'n_points' key for number of points.
        """
        self.n_points = kwargs.get('n_points', 10)  # Default to 10 points.

    def get_tangent_points(self):
        """
        Generate tangent points using Fibonacci sphere sampling.
        """
        indices = np.arange(0, self.n_points) + 0.5
        phi = 2 * np.pi * indices / ((1 + np.sqrt(5)) / 2)  # Golden angle
        theta = np.arccos(1 - 2 * indices / self.n_points)  # Polar angle
        x = np.sin(theta) * np.cos(phi)
        y = np.sin(theta) * np.sin(phi)
        z = np.cos(theta)
        return [self._cartesian_to_lat_lon((x[i], y[i], z[i])) for i in range(len(x))]

    @staticmethod
    def _cartesian_to_lat_lon(cartesian):
        """
        Convert Cartesian coordinates to latitude and longitude.
        """
        x, y, z = cartesian
        latitude = np.degrees(np.arcsin(z))
        longitude = np.degrees(np.arctan2(y, x))
        return latitude, longitude
    


SAMPLER_CLASSES = {
    "CubeSampler": CubeSampler,
    "IcosahedronSampler": IcosahedronSampler,
    "FibonacciSampler": FibonacciSampler,
    # Add other sampler classes here if needed
}

class SamplerConfig:
    """Configuration for the sampler."""
    def __init__(self, sampler_cls="CubeSampler", **sampler_kwargs):
        """
        Initialize sampler configuration.

        :param sampler_cls: Sampler class to be instantiated (can be a string or class).
        :param sampler_kwargs: Additional keyword arguments for the sampler.
        """
        if isinstance(sampler_cls, str):
            if sampler_cls not in SAMPLER_CLASSES:
                raise ValueError(f"Unknown sampler class name: {sampler_cls}")
            self.sampler_cls = SAMPLER_CLASSES[sampler_cls]
        else:
            self.sampler_cls = sampler_cls
        self.sampler_kwargs = sampler_kwargs

    def create_sampler(self):
        """
        Instantiate and return the sampler based on configuration.

        :return: Sampler instance.
        """
        return self.sampler_cls(**self.sampler_kwargs)


### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/__init__.py ###


### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/__init__.py ###
from .projection import ProjectionRegistry

__all__ = ["ProjectionRegistry"]

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/__init__.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/__init__.py

"""
Gnomonic Projection Package

This package provides functionalities for gnomonic projections,
including registry management and default projection registration.
"""

from .registry import ProjectionRegistry
from .default_projections import register_default_projections
from .logging_config import setup_logging

# Set up logging
logger = setup_logging()
logger.info("Initializing Gnomonic Projection Package")

# Automatically register default projections
try:
    register_default_projections()
    logger.info("Default projections registered successfully.")
except Exception as e:
    logger.exception("Failed to register default projections.")
    raise RuntimeError("Failed to register default projections.") from e

__all__ = ["ProjectionRegistry"]

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/base/__init__.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/base/__init__.py

"""
Base module for gnomonic projection components.

This module includes base classes for projection configuration,
strategy, grid generation, interpolation, and coordinate transformations.
"""

from .config import BaseProjectionConfig
from .strategy import BaseProjectionStrategy
from .grid import BaseGridGeneration
from .interpolation import BaseInterpolation
from .transform import BaseCoordinateTransformer
from ..exceptions import (
    ProjectionError,
    ConfigurationError,
    RegistrationError,
    ProcessingError,
    GridGenerationError,
    TransformationError,
    InterpolationError,
)

__all__ = [
    "BaseProjectionConfig",
    "BaseProjectionStrategy",
    "BaseGridGeneration",
    "BaseInterpolation",
    "BaseCoordinateTransformer",
    "ProjectionError",
    "ConfigurationError",
    "RegistrationError",
    "ProcessingError",
    "GridGenerationError",
    "TransformationError",
    "InterpolationError",
]

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/base/config.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/base/config.py

from typing import Any, Dict, Optional
from pydantic import BaseModel, Field, validator
from ..base.interpolation import BaseInterpolation
from ..exceptions import ConfigurationError
import logging

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.config')

class BaseProjectionConfigModel(BaseModel):
    """
    Pydantic model holding basic projection configuration parameters.

    Attributes:
        interpolation (Optional[int]): Interpolation method for OpenCV remap.
        borderMode (Optional[int]): Border mode for OpenCV remap.
        borderValue (Optional[Any]): Border value for OpenCV remap.
    """
    interpolation: Optional[int] = Field(default=0, description="Interpolation method for OpenCV remap")
    borderMode: Optional[int] = Field(default=0, description="Border mode for OpenCV remap")
    borderValue: Optional[Any] = Field(default=0, description="Border value for OpenCV remap")

    class Config:
        arbitrary_types_allowed = True

class BaseProjectionConfig:
    """
    Base class for projections, allowing dynamic initialization with configuration objects.
    Utilizes Pydantic for configuration validation and management.
    """

    def __init__(self, config_object: Any) -> None:
        """
        Initialize the projection configuration.

        Args:
            config_object (Any): An object (e.g., GnomonicConfig) containing configuration parameters.

        Raises:
            ConfigurationError: If the configuration object does not have a 'config' attribute.
        """
        logger.debug("Initializing BaseProjectionConfig.")
        if not hasattr(config_object, "config"):
            error_msg = "Configuration object must have a 'config' attribute."
            logger.error(error_msg)
            raise ConfigurationError(error_msg)
        self.config_object: Any = config_object
        try:
            self.params: BaseProjectionConfigModel = config_object.config
            logger.debug("Configuration parameters loaded successfully.")
        except Exception as e:
            error_msg = f"Failed to load configuration parameters: {e}"
            logger.exception(error_msg)
            raise ConfigurationError(error_msg) from e
        self.extra_params: Dict[str, Any] = {}

    def create_projection(self) -> Any:
        """
        Placeholder for creating a projection object.
        Subclasses or dynamic creation logic should override this method.

        Raises:
            NotImplementedError: If the method is not overridden by subclasses.
        """
        logger.debug("create_projection method called.")
        raise NotImplementedError("Subclasses or configuration must implement create_projection.")

    def create_grid_generation(self) -> Any:
        """
        Placeholder for creating a grid generation object.
        Subclasses or dynamic creation logic should override this method.

        Raises:
            NotImplementedError: If the method is not overridden by subclasses.
        """
        logger.debug("create_grid_generation method called.")
        raise NotImplementedError("Subclasses or configuration must implement create_grid_generation.")

    def create_interpolation(self) -> BaseInterpolation:
        """
        Create an interpolation object using the configuration.

        Returns:
            BaseInterpolation: The interpolation object.
        """
        logger.debug("Creating interpolation object.")
        return BaseInterpolation(self)

    def create_transformer(self) -> Any:
        """
        Placeholder for creating a transformer object.

        Raises:
            NotImplementedError: If the method is not overridden by subclasses.
        """
        logger.debug("create_transformer method called.")
        raise NotImplementedError("Subclasses or configuration must implement create_transformer.")

    def update(self, **kwargs: Any) -> None:
        """
        Update configuration parameters dynamically.

        Args:
            **kwargs (Any): Parameters to update in the configuration.
        """
        logger.debug(f"Updating configuration with parameters: {kwargs}")
        for key, value in kwargs.items():
            if key in self.params.__fields__:
                try:
                    setattr(self.params, key, value)
                    logger.debug(f"Parameter '{key}' updated to {value}.")
                except Exception as e:
                    error_msg = f"Failed to update parameter '{key}': {e}"
                    logger.exception(error_msg)
                    raise ConfigurationError(error_msg) from e
            else:
                self.extra_params[key] = value
                logger.debug(f"Extra parameter '{key}' set to {value}.")

    def __getattr__(self, item: str) -> Any:
        """
        Access configuration parameters as attributes.

        Args:
            item (str): Parameter name.

        Returns:
            Any: The value of the parameter if it exists.

        Raises:
            AttributeError: If the parameter does not exist.
        """
        logger.debug(f"Accessing attribute '{item}'.")
        if hasattr(self.config_object, item):
            return getattr(self.config_object, item)
        if item in self.extra_params:
            return self.extra_params[item]
        error_msg = f"'{type(self).__name__}' object has no attribute '{item}'"
        logger.error(error_msg)
        raise AttributeError(error_msg)

    def __repr__(self) -> str:
        """
        String representation of the configuration.

        Returns:
            str: Human-readable string of configuration parameters.
        """
        return f"BaseProjectionConfig(params={self.params.dict()}, extra_params={self.extra_params})"

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/base/grid.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/base/grid.py

from typing import Any, Tuple
import numpy as np
import logging
from ..exceptions import GridGenerationError, ProcessingError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.grid')

class BaseGridGeneration:
    """
    Base class for grid generation in projections.
    """

    def __init__(self, config):
        """
        Initialize the BaseGridGeneration with the given configuration.

        Args:
            config (Any): Projection configuration object.
        """
        logger.debug("Initializing BaseGridGeneration.")
        self.config = config

    def projection_grid(self) -> Tuple[np.ndarray, np.ndarray]:
        """
        Placeholder method to generate the grid for forward projection.

        Returns:
            Tuple[np.ndarray, np.ndarray]: The X and Y coordinate grids.

        Raises:
            NotImplementedError: If the subclass does not implement this method.
        """
        logger.debug("projection_grid method called (Base class).")
        raise NotImplementedError("Subclasses must implement _create_grid.")

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/base/interpolation.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/base/interpolation.py

from typing import Any, Optional
import cv2
import numpy as np
import logging
from ..exceptions import InterpolationError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.interpolation')

class BaseInterpolation:
    """
    Base class for image interpolation in projections.
    """

    def __init__(self, config: Any) -> None:
        """
        Initialize the interpolation with the given configuration.

        Args:
            config (Any): The projection configuration.

        Raises:
            TypeError: If 'config' does not have required attributes.
        """
        logger.debug("Initializing BaseInterpolation.")
        if not hasattr(config, "interpolation") or not hasattr(config, "borderMode") or not hasattr(config, "borderValue"):
            error_msg = "Config must have 'interpolation', 'borderMode', and 'borderValue' attributes."
            logger.error(error_msg)
            raise TypeError(error_msg)
        self.config: Any = config
        logger.info("BaseInterpolation initialized successfully.")

    def interpolate(
        self, 
        input_img: np.ndarray, 
        map_x: np.ndarray, 
        map_y: np.ndarray, 
        mask: Optional[np.ndarray] = None
    ) -> np.ndarray:
        """
        Perform image interpolation based on the provided mapping.

        Args:
            input_img (np.ndarray): The input image to interpolate.
            map_x (np.ndarray): The mapping for the x-coordinates.
            map_y (np.ndarray): The mapping for the y-coordinates.
            mask (Optional[np.ndarray], optional): Mask to apply to the interpolated image. Defaults to None.

        Returns:
            np.ndarray: The interpolated image.

        Raises:
            InterpolationError: If OpenCV remap fails or inputs are invalid.
        """
        logger.debug("Starting image interpolation.")
        if not isinstance(input_img, np.ndarray):
            error_msg = "input_img must be a NumPy ndarray."
            logger.error(error_msg)
            raise InterpolationError(error_msg)
        if not isinstance(map_x, np.ndarray) or not isinstance(map_y, np.ndarray):
            error_msg = "map_x and map_y must be NumPy ndarrays."
            logger.error(error_msg)
            raise InterpolationError(error_msg)

        try:
            map_x_32: np.ndarray = map_x.astype(np.float32)
            map_y_32: np.ndarray = map_y.astype(np.float32)
            logger.debug("map_x and map_y converted to float32 successfully.")
        except Exception as e:
            error_msg = f"Failed to convert map_x or map_y to float32: {e}"
            logger.exception(error_msg)
            raise InterpolationError(error_msg) from e

        try:
            result: np.ndarray = cv2.remap(
                input_img, map_x_32, map_y_32,
                interpolation=self.config.interpolation,
                borderMode=self.config.borderMode,
                borderValue=self.config.borderValue
            )
            logger.debug("OpenCV remap executed successfully.")
        except cv2.error as e:
            error_msg = f"OpenCV remap failed: {e}"
            logger.exception(error_msg)
            raise InterpolationError(error_msg) from e

        if mask is not None:
            logger.debug("Applying mask to interpolated image.")
            if not isinstance(mask, np.ndarray):
                error_msg = "mask must be a NumPy ndarray if provided."
                logger.error(error_msg)
                raise InterpolationError(error_msg)
            if mask.shape != result.shape[:2]:
                error_msg = "mask shape must match the first two dimensions of the result."
                logger.error(error_msg)
                raise InterpolationError(error_msg)
            result *= mask[:, :, None]
            logger.debug("Mask applied successfully.")

        logger.info("Image interpolation completed successfully.")
        return result

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/base/registry.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/base/registry.py

from typing import Any, Dict, Optional, Type, Union
import logging

logger = logging.getLogger('gnomonic_projection.registry')

class RegistryBase(type):
    """
    Metaclass to automatically register classes in a central REGISTRY dictionary.
    """

    REGISTRY = {}

    def __new__(cls, name, bases, attrs):
        """
        Create a new class and register it in the REGISTRY.
        """
        new_cls = type.__new__(cls, name, bases, attrs)
        cls.REGISTRY[new_cls.__name__] = new_cls
        return new_cls

    @classmethod
    def get_registry(cls):
        """
        Retrieve the dictionary of all registered classes.
        
        Returns:
            dict: Copy of the class registry.
        """
        return dict(cls.REGISTRY)

class BaseRegisteredClass(metaclass=RegistryBase):
    """
    Base class that uses the RegistryBase metaclass for automatic registration.
    """
    pass

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/base/strategy.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/base/strategy.py

from typing import Any, Tuple
import numpy as np
import logging
from ..exceptions import ProcessingError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.strategy')

class BaseProjectionStrategy:
    """
    Base class for projection strategies.
    """

    @classmethod
    def from_spherical_to_projection(self, x: np.ndarray, y: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        Perform forward projection from grid coordinates to latitude and longitude.

        Args:
            x (np.ndarray): X-coordinates in the grid.
            y (np.ndarray): Y-coordinates in the grid.

        Returns:
            Tuple[np.ndarray, np.ndarray]: Latitude and longitude arrays.

        Raises:
            ProcessingError: If inputs are not valid NumPy arrays or method is not overridden.
        """
        logger.debug("Starting forward projection in BaseProjectionStrategy.")
        if not isinstance(x, np.ndarray) or not isinstance(y, np.ndarray):
            error_msg = "x and y must be NumPy ndarrays."
            logger.error(error_msg)
            raise ProcessingError(error_msg)
        logger.debug("Forward projection inputs are valid.")
        raise NotImplementedError("Subclasses must implement forward.")

    @classmethod
    def from_projection_to_spherical(self, lat: np.ndarray, lon: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Perform backward projection from latitude and longitude to grid coordinates.

        Args:
            lat (np.ndarray): Latitude values.
            lon (np.ndarray): Longitude values.

        Returns:
            Tuple[np.ndarray, np.ndarray, np.ndarray]: X and Y coordinates in the grid, and a mask array.

        Raises:
            ProcessingError: If inputs are not valid NumPy arrays or method is not overridden.
        """
        logger.debug("Starting backward projection in BaseProjectionStrategy.")
        if not isinstance(lat, np.ndarray) or not isinstance(lon, np.ndarray):
            error_msg = "lat and lon must be NumPy ndarrays."
            logger.error(error_msg)
            raise ProcessingError(error_msg)
        logger.debug("Backward projection inputs are valid.")
        raise NotImplementedError("Subclasses must implement backward.")

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/base/transform.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/base/transform.py

from typing import Any, Tuple
import numpy as np
import logging
from ..exceptions import TransformationError, ConfigurationError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.transform')

class BaseCoordinateTransformer:
    """
    Utility class for transforming coordinates between different systems.
    """

    def __init__(self, config) -> None:
        """
        Initialize the BaseCoordinateTransformer with a given configuration.

        Args:
            config: The configuration containing necessary projection parameters.
        """
        logger.debug("Initializing BaseCoordinateTransformer.")
        self.config = config

    @classmethod
    def spherical_to_image_coords(
        lat: np.ndarray, 
        lon: np.ndarray, 
        config: Any, 
        shape: Tuple[int, int, ...]
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Placeholder method for converting spherical coordinates to image coordinates.

        Raises:
            NotImplementedError: This method must be implemented by a subclass.
        """
        raise NotImplementedError("Subclasses must implement forward.")

    @staticmethod
    def projection_to_image_coords(
        x: np.ndarray, 
        y: np.ndarray, 
        config: Any
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Placeholder method for converting projection coordinates to image coordinates.

        Raises:
            NotImplementedError: This method must be implemented by a subclass.
        """
        raise NotImplementedError("Subclasses must implement forward.")

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/default_projections.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/default_projections.py

from .registry import ProjectionRegistry

from .gnomonic.config import GnomonicConfig
from .gnomonic.grid import GnomonicGridGeneration
from .gnomonic.strategy import GnomonicProjectionStrategy
from .gnomonic.transform import GnomonicTransformer  # Updated to per-projection transformer

from .mercator.config import MercatorConfig
from .mercator.grid import MercatorGridGeneration
from .mercator.strategy import MercatorProjectionStrategy
from .mercator.transform import MercatorTransformer  # Updated to per-projection transformer

from .base.interpolation import BaseInterpolation
from .exceptions import RegistrationError
import logging

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.default_projections')

def register_default_projections():
    """
    Register default projections with their components.

    Raises:
        RegistrationError: If registration of any default projection fails.
    """
    logger.debug("Registering default projections.")
    try:
        # Register Gnomonic projection
        ProjectionRegistry.register("gnomonic", {
            "config": GnomonicConfig,
            "grid_generation": GnomonicGridGeneration,
            "projection_strategy": GnomonicProjectionStrategy,
            "interpolation": BaseInterpolation,
            "transformer": GnomonicTransformer,  # Updated to GnomonicTransformer
        })
        logger.info("Default projection 'gnomonic' registered successfully.")

        # Register Mercator projection
        ProjectionRegistry.register("mercator", {
            "config": MercatorConfig,
            "grid_generation": MercatorGridGeneration,
            "projection_strategy": MercatorProjectionStrategy,
            "interpolation": BaseInterpolation,
            "transformer": MercatorTransformer,  # Updated to MercatorTransformer
        })


        logger.info("Default projection 'mercator' registered successfully.")

    except RegistrationError as e:
        logger.exception("Failed to register default projections.")
        raise RegistrationError(f"Failed to register default projections: {e}") from e
    except Exception as e:
        logger.exception("An unexpected error occurred while registering default projections.")
        raise RegistrationError(f"An unexpected error occurred: {e}") from e

    logger.debug("All default projections registered.")

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/exceptions.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/exceptions.py

"""
Custom exception classes for the Gnomonic Projection module.
"""

class ProjectionError(Exception):
    """Base exception for projection-related errors."""
    pass

class ConfigurationError(ProjectionError):
    """Exception raised for configuration-related issues."""
    pass

class RegistrationError(ProjectionError):
    """Exception raised during projection registration."""
    pass

class ProcessingError(ProjectionError):
    """Exception raised during projection processing."""
    pass

class GridGenerationError(ProjectionError):
    """Exception raised during grid generation."""
    pass

class TransformationError(ProjectionError):
    """Exception raised during coordinate transformations."""
    pass

class InterpolationError(ProjectionError):
    """Exception raised during image interpolation."""
    pass

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/gnomonic/__init__.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/__init__.py

"""
Gnomonic Projection Module

This module provides specific implementations for Gnomonic projections,
including configuration, projection strategies, and grid generation.

## Mathematical Foundation

The Gnomonic projection transforms points on the surface of a sphere (e.g., Earth)
onto a plane using a projection point located at the center of the sphere.
This projection is based on the principles of spherical trigonometry and can be
derived using the following key equations:

1. **Projection Equations:** (See inline formulas in the docstring)

2. **Special Cases:** 
   Polar Gnomonic Projection examples and usage.

The Gnomonic projection is particularly useful for mapping great circles as straight lines,
which is advantageous in navigation and aeronautics.

## Projection Processes

1. **Forward Projection:** 
   Maps points from an equirectangular (input) image to the Gnomonic projection plane.

2. **Backward Projection:**
   Maps points from the Gnomonic projection plane back to an equirectangular (output) image.

## Usage

See the example usage in the docstring below.
"""

import logging

from .config import GnomonicConfig
from .strategy import GnomonicProjectionStrategy
from .grid import GnomonicGridGeneration
from .transform import GnomonicTransformer
from ..logging_config import setup_logging

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.gnomonic')

def initialize_gnomonic_module():
    """
    Initialize the Gnomonic Projection module.

    This initialization sets up any module-specific configurations or prerequisites.
    Currently, it primarily logs the initialization status.
    """
    logger.debug("Initializing Gnomonic Projection Module.")
    # Any module-specific initialization can be done here
    logger.info("Gnomonic Projection Module initialized successfully.")

# Call the initialization function upon import
initialize_gnomonic_module()

__all__ = [
    "GnomonicConfig",
    "GnomonicProjectionStrategy",
    "GnomonicGridGeneration",
    "GnomonicTransformer"
]

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/gnomonic/config.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/config.py

from typing import Any, Optional
from pydantic import BaseModel, Field, validator
import cv2
import logging
from ..exceptions import ConfigurationError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.gnomonic.config')

class GnomonicConfigModel(BaseModel):
    """
    Pydantic model for Gnomonic projection configuration.

    Attributes include radius of the Earth, center latitude and longitude,
    field of view, grid resolutions, bounding box for lat/lon, and interpolation
    parameters.
    """
    R: float = Field(1.0, description="Radius of the sphere (e.g., Earth) in consistent units.")
    phi1_deg: float = Field(0.0, description="Latitude of the projection center in degrees.")
    lam0_deg: float = Field(0.0, description="Longitude of the projection center in degrees.")
    fov_deg: float = Field(90.0, description="Field of view in degrees.")
    x_points: int = Field(512, description="Number of grid points in the x-direction.")
    y_points: int = Field(512, description="Number of grid points in the y-direction.")
    lon_points: int = Field(1024, description="Number of longitude points for inverse grid mapping.")
    lat_points: int = Field(512, description="Number of latitude points for inverse grid mapping.")
    lon_min: float = Field(-180.0, description="Minimum longitude in the grid (degrees).")
    lon_max: float = Field(180.0, description="Maximum longitude in the grid (degrees).")
    lat_min: float = Field(-90.0, description="Minimum latitude in the grid (degrees).")
    lat_max: float = Field(90.0, description="Maximum latitude in the grid (degrees).")
    interpolation: Optional[int] = Field(default=cv2.INTER_LINEAR, description="Interpolation method for OpenCV remap.")
    borderMode: Optional[int] = Field(default=cv2.BORDER_CONSTANT, description="Border mode for OpenCV remap.")
    borderValue: Optional[Any] = Field(default=0, description="Border value for OpenCV remap.")

    @validator('fov_deg')
    def validate_fov(cls, v):
        """
        Validate that the field of view is between 0 and 180 degrees.
        """
        if not (0 < v < 180):
            raise ValueError("Field of view (fov_deg) must be between 0 and 180 degrees.")
        return v

    class Config:
        arbitrary_types_allowed = True

class GnomonicConfig:
    """
    Configuration class for Gnomonic projections using Pydantic for validation.

    This class encapsulates all necessary parameters required to perform both forward (equirectangular to Gnomonic)
    and inverse (Gnomonic to equirectangular) projections. It ensures that configurations are validated
    and managed efficiently.
    """

    def __init__(self, **kwargs: Any) -> None:
        """
        Initialize the GnomonicConfig with provided parameters.

        Args:
            **kwargs (Any): Configuration parameters as keyword arguments.

        Raises:
            ConfigurationError: If initialization fails due to invalid parameters.
        """
        logger.debug("Initializing GnomonicConfig with parameters: %s", kwargs)
        try:
            self.config = GnomonicConfigModel(**kwargs)
            logger.info("GnomonicConfig initialized successfully.")
        except Exception as e:
            error_msg = f"Failed to initialize GnomonicConfig: {e}"
            logger.exception(error_msg)
            raise ConfigurationError(error_msg) from e

    def update(self, **kwargs: Any) -> None:
        """
        Update configuration parameters dynamically.

        Args:
            **kwargs (Any): Parameters to update in the configuration.

        Raises:
            ConfigurationError: If updating fails due to invalid parameters.
        """
        logger.debug(f"Updating GnomonicConfig with parameters: {kwargs}")
        try:
            updated_config = self.config.copy(update=kwargs)
            self.config = updated_config
            logger.info("GnomonicConfig updated successfully.")
        except Exception as e:
            error_msg = f"Failed to update GnomonicConfig: {e}"
            logger.exception(error_msg)
            raise ConfigurationError(error_msg) from e

    def __getattr__(self, item: str) -> Any:
        """
        Access configuration parameters as attributes.

        Args:
            item (str): Parameter name.

        Returns:
            Any: The value of the parameter if it exists.

        Raises:
            AttributeError: If the parameter does not exist.
        """
        logger.debug(f"Accessing GnomonicConfig attribute '{item}'.")
        try:
            return getattr(self.config, item)
        except AttributeError:
            error_msg = f"'GnomonicConfig' object has no attribute '{item}'"
            logger.error(error_msg)
            raise AttributeError(error_msg) from None

    def __repr__(self) -> str:
        """
        String representation of the configuration.

        Returns:
            str: Human-readable string of configuration parameters.
        """
        return f"GnomonicConfig({self.config.dict()})"

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/gnomonic/grid.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/grid.py

from typing import Any, Tuple
from ..base.grid import BaseGridGeneration
from .config import GnomonicConfig
from ..exceptions import GridGenerationError
import numpy as np
import logging

logger = logging.getLogger('gnomonic_projection.gnomonic.grid')

class GnomonicGridGeneration(BaseGridGeneration):
    """
    Grid generation for the Gnomonic projection.
    """

    def projection_grid(self, delta_lat=0, delta_lon=0):
        """
        Generate the forward-projection grid (X, Y) for the Gnomonic projection.

        Returns:
            Tuple[np.ndarray, np.ndarray]: The X and Y coordinate grids for forward projection.
        """
        logger.debug("Generating Gnomonic projection grid.")
        half_fov_rad = np.deg2rad(self.config.fov_deg / 2)
        x_max = np.tan(half_fov_rad) * self.config.R
        y_max = np.tan(half_fov_rad) * self.config.R
        x_vals = np.linspace(-x_max, x_max, self.config.x_points)
        y_vals = np.linspace(-y_max, y_max, self.config.y_points)
        grid_x, grid_y = np.meshgrid(x_vals, y_vals)
        return grid_x, grid_y

    def spherical_grid(self, delta_lat=0, delta_lon=0):
        """
        Generate the (lon, lat) grid for backward projection.

        Returns:
            Tuple[np.ndarray, np.ndarray]: The longitude and latitude grids.
        """
        logger.debug("Generating Gnomonic spherical grid.")
        lon_vals = np.linspace(self.config.lon_min, self.config.lon_max, self.config.lon_points) + delta_lon
        lat_vals = np.linspace(self.config.lat_min, self.config.lat_max, self.config.lat_points) + delta_lat
        grid_lon, grid_lat = np.meshgrid(lon_vals, lat_vals)
        return grid_lon, grid_lat

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/gnomonic/strategy.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/strategy.py

from typing import Any, Tuple
from ..base.strategy import BaseProjectionStrategy
from .config import GnomonicConfig
from ..exceptions import ProcessingError
import numpy as np
import logging

logger = logging.getLogger('gnomonic_projection.gnomonic.strategy')

class GnomonicProjectionStrategy(BaseProjectionStrategy):
    """
    Projection Strategy for Gnomonic Projection.

    This class implements the transformation logic for both forward (Equirectangular to Gnomonic)
    and inverse (Gnomonic to Equirectangular) projections based on spherical trigonometry.
    It ensures accurate mapping between geographic coordinates and planar projection coordinates.
    """

    def __init__(self, config: GnomonicConfig) -> None:
        """
        Initialize the GnomonicProjectionStrategy with the given configuration.

        Args:
            config (GnomonicConfig): The configuration object containing projection parameters.

        Raises:
            TypeError: If the config is not an instance of GnomonicConfig.
        """
        logger.debug("Initializing GnomonicProjectionStrategy.")
        if not isinstance(config, GnomonicConfig):
            error_msg = f"config must be an instance of GnomonicConfig, got {type(config)} instead."
            logger.error(error_msg)
            raise TypeError(error_msg)
        self.config: GnomonicConfig = config
        logger.info("GnomonicProjectionStrategy initialized successfully.")

    def from_projection_to_spherical(self, x: np.ndarray, y: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        Perform inverse Gnomonic projection from planar grid coordinates to geographic coordinates.

        Args:
            x (np.ndarray): X-coordinates in the planar grid.
            y (np.ndarray): Y-coordinates in the planar grid.

        Returns:
            Tuple[np.ndarray, np.ndarray]: Arrays of latitude and longitude corresponding to the input grid points.

        Raises:
            ProcessingError: If the projection computation fails.
        """
        logger.debug("Starting inverse Gnomonic projection (Planar to Geographic).")
        try:
            phi1_rad, lam0_rad = np.deg2rad([self.config.phi1_deg, self.config.lam0_deg])
            logger.debug(f"Projection center (phi1_rad, lam0_rad): ({phi1_rad}, {lam0_rad})")

            rho = np.sqrt(x**2 + y**2)
            logger.debug("Computed rho (radial distances) from grid points.")

            c = np.arctan2(rho, self.config.R)
            sin_c, cos_c = np.sin(c), np.cos(c)
            logger.debug(f"Computed auxiliary angles c, sin_c, cos_c for rho.")

            phi = np.arcsin(cos_c * np.sin(phi1_rad) - (y * sin_c * np.cos(phi1_rad)) / rho)
            logger.debug("Computed latitude (phi) for inverse projection.")

            lam = lam0_rad + np.arctan2(
                x * sin_c,
                rho * np.cos(phi1_rad) * cos_c + y * np.sin(phi1_rad) * sin_c
            )
            logger.debug("Computed longitude (lambda) for inverse projection.")

            lat = np.rad2deg(phi)
            lon = np.rad2deg(lam)
            logger.debug("Converted phi and lambda from radians to degrees.")

            logger.debug("Inverse Gnomonic projection computed successfully.")
            return lat, lon
        except Exception as e:
            error_msg = f"Failed during inverse Gnomonic projection: {e}"
            logger.exception(error_msg)
            raise ProcessingError(error_msg) from e

    def from_spherical_to_projection(self, lat: np.ndarray, lon: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Perform forward Gnomonic projection from geographic coordinates to planar grid coordinates.

        Args:
            lat (np.ndarray): Latitude values in degrees.
            lon (np.ndarray): Longitude values in degrees.

        Returns:
            Tuple[np.ndarray, np.ndarray, np.ndarray]: Arrays of X and Y planar coordinates and a mask indicating valid points.

        Raises:
            ProcessingError: If the projection computation fails.
        """
        logger.debug("Starting forward Gnomonic projection (Geographic to Planar).")
        try:
            phi1_rad, lam0_rad = np.deg2rad([self.config.phi1_deg, self.config.lam0_deg])
            logger.debug(f"Projection center (phi1_rad, lam0_rad): ({phi1_rad}, {lam0_rad})")

            phi_rad, lam_rad = np.deg2rad([lat, lon])
            logger.debug("Converted input lat/lon to radians.")

            cos_c = (
                np.sin(phi1_rad) * np.sin(phi_rad) +
                np.cos(phi1_rad) * np.cos(phi_rad) * np.cos(lam_rad - lam0_rad)
            )
            logger.debug("Computed cos_c for forward projection.")

            cos_c = np.where(cos_c == 0, 1e-10, cos_c)
            logger.debug("Adjusted cos_c to avoid division by zero.")

            x = self.config.R * np.cos(phi_rad) * np.sin(lam_rad - lam0_rad) / cos_c
            logger.debug("Computed X planar coordinates for forward projection.")

            y = self.config.R * (
                np.cos(phi1_rad) * np.sin(phi_rad) -
                np.sin(phi1_rad) * np.cos(phi_rad) * np.cos(lam_rad - lam0_rad)
            ) / cos_c
            logger.debug("Computed Y planar coordinates for forward projection.")

            mask = cos_c > 0
            logger.debug("Generated mask for valid projection points (cos_c > 0).")

            logger.debug("Forward Gnomonic projection computed successfully.")
            return x, y, mask
        except Exception as e:
            error_msg = f"Failed during forward Gnomonic projection: {e}"
            logger.exception(error_msg)
            raise ProcessingError(error_msg) from e

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/gnomonic/transform.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/transform.py

from typing import Tuple, Any
import numpy as np
import logging
from ..exceptions import TransformationError, ConfigurationError
from ..base.transform import BaseCoordinateTransformer

# Configure logger for the transformation module
logger = logging.getLogger('gnomonic_projection.gnomonic.transform')

class GnomonicTransformer(BaseCoordinateTransformer):
    """
    Transformation Logic for Gnomonic Projection.

    The `GnomonicTransformer` class handles the conversion between geographic coordinates
    (latitude and longitude) and image coordinates on the Gnomonic projection plane.
    """

    def __init__(self, config):
        """
        Initialize the GnomonicTransformer with the given configuration.

        Args:
            config: Configuration object containing necessary projection parameters.
        """
        logger.debug("Initializing GnomonicTransformer.")
        required_attributes = [
            "lon_min",
            "lon_max",
            "lat_min",
            "lat_max",
            "fov_deg",
            "R",
            "x_points",
            "y_points"
        ]
        missing_attributes = [attr for attr in required_attributes if not hasattr(config, attr)]

        if missing_attributes:
            error_msg = f"Configuration object is missing required attributes: {', '.join(missing_attributes)}"
            logger.error(error_msg)
            raise ConfigurationError(error_msg)

        self.config = config
        logger.info("GnomonicTransformer initialized successfully.")

    def _validate_inputs(self, array: np.ndarray, name: str) -> None:
        """
        Validate input arrays to ensure they are NumPy arrays.

        Args:
            array (np.ndarray): Input array to validate.
            name (str): Name of the array for error messages.

        Raises:
            TransformationError: If the input is not a NumPy ndarray.
        """
        if not isinstance(array, np.ndarray):
            error_msg = f"{name} must be a NumPy ndarray."
            logger.error(error_msg)
            raise TransformationError(error_msg)

    def _compute_image_coords(
        self, values: np.ndarray, min_val: float, max_val: float, size: int
    ) -> np.ndarray:
        """
        Generalized method to compute normalized image coordinates.

        Args:
            values (np.ndarray): Input values to normalize (e.g., lat, lon, x, y).
            min_val (float): Minimum value for normalization.
            max_val (float): Maximum value for normalization.
            size (int): Size of the target axis.

        Returns:
            np.ndarray: Normalized image coordinates scaled to [0, size-1].
        """
        normalized = (values - min_val) / (max_val - min_val) * (size - 1)
        logger.debug(f"Computed normalized image coordinates.")
        return normalized

    def spherical_to_image_coords(
        self, lat: np.ndarray, lon: np.ndarray, shape: Tuple[int, int]
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Convert spherical coordinates (lat, lon) to image coordinates.

        Args:
            lat (np.ndarray): Array of latitude values.
            lon (np.ndarray): Array of longitude values.
            shape (Tuple[int, int]): Shape of the image (height, width).

        Returns:
            Tuple[np.ndarray, np.ndarray]: Image coordinates map_x, map_y.
        """
        logger.debug("Mapping spherical coordinates to image coordinates for Gnomonic projection.")
        H, W = shape  

        # Clamp extreme values if necessary (example only, logic unchanged)
        lon[lon>180] = 180 - lon[lon>180]
        lat[lat>90] = 90 - lat[lat>90]

        map_x = self._compute_image_coords(
            lon, self.config.lon_min, self.config.lon_max, W
        )
        map_y = self._compute_image_coords(
            lat, self.config.lat_max, self.config.lat_min, H
        )
        return map_x, map_y

    def projection_to_image_coords(
        self, x: np.ndarray, y: np.ndarray, config: Any
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Convert Gnomonic planar coordinates (x, y) to image coordinates.

        Args:
            x (np.ndarray): Planar X-coordinates.
            y (np.ndarray): Planar Y-coordinates.
            config (Any): Projection configuration object with fov_deg, R, etc.

        Returns:
            Tuple[np.ndarray, np.ndarray]: Image coordinates map_x, map_y.
        """
        logger.debug("Mapping Gnomonic planar coordinates to image coordinates.")
        half_fov_rad = np.deg2rad(config.fov_deg / 2)
        x_max = np.tan(half_fov_rad) * config.R
        y_max = np.tan(half_fov_rad) * config.R
        x_min, y_min = -x_max, -y_max

        map_x = self._compute_image_coords(x, x_min, x_max, config.x_points)
        map_y = self._compute_image_coords(y, y_max, y_min, config.y_points)

        return map_x, map_y

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/logging_config.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/logging_config.py

"""
Logging configuration for the Gnomonic Projection module.
"""

import logging
import sys

def setup_logging():
    """
    Set up logging configuration.

    Returns:
        logging.Logger: Configured logger for the 'gnomonic_projection' namespace.
    """
    logger = logging.getLogger('gnomonic_projection')
    logger.setLevel(logging.DEBUG)  # Set to DEBUG to capture all levels of logs

    # Create handlers
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)  # Set to INFO for console output

    file_handler = logging.FileHandler('gnomonic_projection.log')
    file_handler.setLevel(logging.DEBUG)  # Detailed logs in file

    # Create formatters and add them to handlers
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console_handler.setFormatter(formatter)
    file_handler.setFormatter(formatter)

    # Add handlers to the logger
    if not logger.hasHandlers():
        logger.addHandler(console_handler)
        logger.addHandler(file_handler)

    return logger

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/mercator/__init__.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/mercator/__init__.py

from .config import MercatorConfig
from .grid import MercatorGridGeneration
from .strategy import MercatorProjectionStrategy

__all__ = [
    "MercatorConfig",
    "MercatorGridGeneration",
    "MercatorProjectionStrategy",
]

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/mercator/config.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/mercator/config.py

from typing import Any, Optional
from pydantic import BaseModel, Field
import cv2
import logging
from ..exceptions import ConfigurationError

logger = logging.getLogger('projection.mercator.config')

class MercatorConfigModel(BaseModel):
    """
    Pydantic model for the Mercator projection.

    Attributes:
        R (float): Radius of the sphere.
        lon_min (float): Minimum longitude.
        lon_max (float): Maximum longitude.
        lat_min (float): Minimum latitude.
        lat_max (float): Maximum latitude.
        x_points (int): Number of points along the x-axis.
        y_points (int): Number of points along the y-axis.
        fov_deg (float): Field of view in degrees.
        interpolation (Optional[int]): Interpolation method for OpenCV remap.
        borderMode (Optional[int]): Border mode for OpenCV remap.
        borderValue (Optional[Any]): Border value for OpenCV remap.
    """
    R: float = Field(1., description="Radius of the sphere (in kilometers).")
    lon_min: float = Field(-180.0, description="Minimum longitude.")
    lon_max: float = Field(180.0, description="Maximum longitude.")
    lat_min: float = Field(-85.0, description="Minimum latitude (restricted for Mercator).")
    lat_max: float = Field(85.0, description="Maximum latitude (restricted for Mercator).")
    x_points: int = Field(1024, description="Number of points along the x-axis.")
    y_points: int = Field(512, description="Number of points along the y-axis.")
    fov_deg: float = Field(90.0, description="Field of view in degrees")
    interpolation: Optional[int] = Field(default=cv2.INTER_LINEAR, description="Interpolation method for OpenCV remap")
    borderMode: Optional[int] = Field(default=cv2.BORDER_CONSTANT, description="Border mode for OpenCV remap")
    borderValue: Optional[Any] = Field(default=0, description="Border value for OpenCV remap")

class MercatorConfig:
    """
    Configuration class for Mercator projection.
    """

    def __init__(self, **kwargs):
        """
        Initialize the MercatorConfig with specified parameters.

        Args:
            **kwargs: Arbitrary keyword arguments for config parameters.

        Raises:
            ValueError: If initialization fails due to invalid configuration.
        """
        logger.debug("Initializing MercatorConfig with parameters: %s", kwargs)
        try:
            self.config = MercatorConfigModel(**kwargs)
        except Exception as e:
            logger.error("Failed to initialize MercatorConfig.")
            raise ValueError(f"Configuration error: {e}")

    def __repr__(self):
        """
        Return a string representation of the MercatorConfig.

        Returns:
            str: Stringified config dictionary.
        """
        return f"MercatorConfig({self.config.dict()})"

    def update(self, **kwargs: Any) -> None:
        """
        Dynamically update the Mercator configuration.

        Args:
            **kwargs (Any): Configuration parameters to update.

        Raises:
            ConfigurationError: If an error occurs during update.
        """
        logger.debug(f"Updating MercatorConfig with parameters: {kwargs}")
        try:
            updated_config = self.config.copy(update=kwargs)
            self.config = updated_config
            logger.info("MercatorConfig updated successfully.")
        except Exception as e:
            error_msg = f"Failed to update MercatorConfig: {e}"
            logger.exception(error_msg)
            raise ConfigurationError(error_msg) from e

    def __getattr__(self, item: str) -> Any:
        """
        Access configuration parameters as attributes.

        Args:
            item (str): Attribute name.

        Returns:
            Any: The value of the attribute if it exists.

        Raises:
            AttributeError: If the attribute does not exist.
        """
        logger.debug(f"Accessing MercatorConfig attribute '{item}'.")
        try:
            return getattr(self.config, item)
        except AttributeError:
            error_msg = f"'MercatorConfig' object has no attribute '{item}'"
            logger.error(error_msg)
            raise AttributeError(error_msg) from None

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/mercator/grid.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/mercator/grid.py

from ..base.grid import BaseGridGeneration
import numpy as np
import logging

logger = logging.getLogger('projection.mercator.grid')

class MercatorGridGeneration(BaseGridGeneration):
    """
    Grid generation for Mercator projection.
    """

    def projection_grid(self):
        """
        Generate the Mercator projection grid (lon, lat).

        Returns:
            Tuple[np.ndarray, np.ndarray]: The longitude and latitude grids for forward projection.
        """
        logger.debug("Generating Mercator projection grid.")
        y_max = np.log(np.tan(np.pi / 4 + np.radians(self.config.config.lat_max) / 2))
        y_min = np.log(np.tan(np.pi / 4 + np.radians(self.config.config.lat_min) / 2))
        lat = np.linspace(y_min, y_max, self.config.config.y_points)
        lon = np.linspace(self.config.config.lon_min, self.config.config.lon_max, self.config.config.x_points)
        lon = np.radians(lon)
        grid_lon, grid_lat = np.meshgrid(lon, lat)
        return grid_lon, grid_lat

    def spherical_grid(self):
        """
        Generate the grid for backward projection in Mercator projection.

        Returns:
            Tuple[np.ndarray, np.ndarray]: The X and Y coordinate grids (map_x, map_y).
        """
        logger.debug("Generating Mercator spherical grid.")
        x = np.linspace(self.config.config.lon_min, self.config.config.lon_max, self.config.config.x_points)
        y = np.linspace(self.config.config.lat_max, self.config.config.lat_min, self.config.config.y_points)
        map_y, map_x = np.meshgrid(x, y)
        return map_x, map_y

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/mercator/strategy.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/mercator/strategy.py

from ..base.strategy import BaseProjectionStrategy
import numpy as np
import logging

logger = logging.getLogger('projection.mercator.strategy')

class MercatorProjectionStrategy(BaseProjectionStrategy):
    """
    Projection strategy for Mercator projection.
    """

    def __init__(self, config):
        """
        Initialize the MercatorProjectionStrategy with the given config.

        Args:
            config: A MercatorConfig instance.
        """
        logger.debug("Initializing MercatorProjectionStrategy.")
        self.config = config

    def from_projection_to_spherical(self, lon: np.ndarray, lat: np.ndarray):
        """
        Perform forward Mercator projection (not typical naming, but as per code).

        Args:
            lon (np.ndarray): Longitude values (radians).
            lat (np.ndarray): Latitude values for the projection (already transformed).

        Returns:
            Tuple[np.ndarray, np.ndarray]: The (lat, lon) in some form.
        """
        lon = lon / self.config.R
        lat =  np.pi / 2 - 2 * np.arctan(np.e**(lat/ self.config.R))
        logger.debug("Mercator forward projection computed successfully.")
        return lat, lon

    def from_spherical_to_projection(self, x: np.ndarray, y: np.ndarray):
        """
        Perform inverse Mercator projection (again, naming reversed in code).

        Args:
            x (np.ndarray): X coordinates (longitudes in degrees).
            y (np.ndarray): Y coordinates (latitudes in degrees).

        Returns:
            Tuple[np.ndarray, np.ndarray, np.ndarray]: The projected X, Y, and a mask.
        """
        logger.debug("Starting inverse Mercator projection (spherical to projection).")
        lon_rad = np.radians(x)
        lat_rad = np.radians(y)
        x = 1 * lon_rad
        y = 1 * np.log(np.tan(np.pi / 4 + lat_rad / 2))
        mask = np.ones_like(x) == 1
        logger.debug("Inverse Mercator projection computed successfully.")
        return x, y, mask

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/mercator/transform.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/mercator/transform.py

from typing import Tuple, Any
import numpy as np
import logging
from ..exceptions import TransformationError, ConfigurationError
from ..base.transform import BaseCoordinateTransformer

logger = logging.getLogger('projection.mercator.transform')

class MercatorTransformer(BaseCoordinateTransformer):
    """
    Transformation logic for the Mercator projection.
    """

    def __init__(self, config):
        """
        Initialize the MercatorTransformer with the given configuration.

        Args:
            config: Configuration object with necessary parameters.

        Raises:
            ConfigurationError: If required attributes are missing.
        """
        logger.debug("Initializing MercatorTransformer.")
        required_attributes = ["lon_min", "lon_max", "lat_min", "lat_max", "x_points", "y_points"]
        missing_attributes = [attr for attr in required_attributes if not hasattr(config, attr)]

        if missing_attributes:
            error_msg = f"Configuration object is missing required attributes: {', '.join(missing_attributes)}"
            logger.error(error_msg)
            raise ConfigurationError(error_msg)

        self.config = config
        logger.info("MercatorTransformer initialized successfully.")

    def spherical_to_image_coords(
        self, lat: np.ndarray, lon: np.ndarray, shape: Tuple[int, int]
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Convert latitude and longitude to Mercator image coordinates.

        Args:
            lat (np.ndarray): Latitude values in degrees.
            lon (np.ndarray): Longitude values in degrees.
            shape (Tuple[int, int]): Shape of the target image (height, width).

        Returns:
            Tuple[np.ndarray, np.ndarray]: X and Y coordinates in image space.

        Raises:
            TransformationError: If input arrays are invalid or computation fails.
        """
        logger.debug("Transforming latitude and longitude to Mercator image coordinates.")
        try:
            if not isinstance(lat, np.ndarray) or not isinstance(lon, np.ndarray):
                raise TypeError("Latitude and longitude must be numpy arrays.")



            # Very simplistic placeholder logic (not a real Mercator transformation).
            x = lon
            y = lat
            map_x = ((x / np.pi) * .5 + .5) * (self.config.x_points - 1)
            map_y = (1 + -1*(( y / (np.pi/2) )* .5 + .5 ))* (self.config.y_points - 1)

            logger.debug("Latitude and longitude transformed successfully.")
            return map_x, map_y

        except Exception as e:
            logger.exception("Failed to transform latitude and longitude to Mercator image coordinates.")
            raise TransformationError(f"Mercator lat/lon transformation failed: {e}")

    def projection_to_image_coords(
        self, x: np.ndarray, y: np.ndarray, shape: Tuple[int, int]
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Transform XY grid coordinates to Mercator image coordinates.

        Args:
            x (np.ndarray): X grid coordinates.
            y (np.ndarray): Y grid coordinates.
            shape (Tuple[int, int]): Shape of the target image (height, width).

        Returns:
            Tuple[np.ndarray, np.ndarray]: X and Y coordinates in image space.

        Raises:
            TransformationError: If input arrays are invalid or computation fails.
        """
        logger.debug("Transforming XY grid coordinates to Mercator image coordinates.")
        try:
            if not isinstance(x, np.ndarray) or not isinstance(y, np.ndarray):
                raise TypeError("Grid coordinates must be numpy arrays.")

            H = self.config.y_points
            W = self.config.x_points
            lon = x
            lat = y

            y_max = np.log(np.tan(np.pi / 4 + np.radians(self.config.config.lat_max) / 2))
            y_min = np.log(np.tan(np.pi / 4 + np.radians(self.config.config.lat_min) / 2))

            map_x = ((lon / np.radians(self.config.config.lon_max)) * .5 + .5) * (self.config.x_points)

            map_y = ((lat - y_min) / (y_max - y_min)) * self.config.y_points

            logger.debug("XY grid coordinates transformed successfully.")
            return map_x, map_y

        except Exception as e:
            logger.exception("Failed to transform XY grid coordinates to Mercator image coordinates.")
            raise TransformationError(f"Mercator XY transformation failed: {e}")

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/processor.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/processor.py

from typing import Any, Optional, Tuple
from .base.config import BaseProjectionConfig
from .exceptions import ProcessingError, InterpolationError, GridGenerationError, TransformationError
import logging
import cv2
import numpy as np
from .utils import PreprocessEquirectangularImage
# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.processor')

class ProjectionProcessor:
    """
    Processor for handling forward and backward projections using the provided configuration.
    """

    def __init__(self, config: BaseProjectionConfig) -> None:
        """
        Initialize the ProjectionProcessor with a given configuration.

        Args:
            config (BaseProjectionConfig): The projection configuration.

        Raises:
            TypeError: If 'config' is not an instance of BaseProjectionConfig.
            ProcessingError: If initialization of components fails.
        """
        logger.debug("Initializing ProjectionProcessor.")
        if not isinstance(config, BaseProjectionConfig):
            error_msg = f"config must be an instance of BaseProjectionConfig, got {type(config)} instead."
            logger.error(error_msg)
            raise TypeError(error_msg)

        self.config: BaseProjectionConfig = config
        try:
            self.projection = config.create_projection()
            self.grid_generation = config.create_grid_generation()
            self.interpolation = config.create_interpolation()
            self.transformer = config.create_transformer()  # Initialize transformer
            logger.info("ProjectionProcessor components initialized successfully.")
        except Exception as e:
            error_msg = f"Failed to initialize ProjectionProcessor components: {e}"
            logger.exception(error_msg)
            raise ProcessingError(error_msg) from e

    def forward(self, img: np.ndarray, **kwargs: Any) -> np.ndarray:
        """
        Forward projection of an image.

        Args:
            img (np.ndarray): The input equirectangular image.
            **kwargs (Any): Additional parameters to override projection configuration.

        Returns:
            np.ndarray: Projected rectilinear image.

        Raises:
            ValueError: If the input image is not a valid NumPy array.
            GridGenerationError: If grid generation fails.
            ProcessingError: If forward projection fails.
            TransformationError: If coordinate transformation fails.
            InterpolationError: If interpolation fails.
        """
        logger.debug("Starting forward projection.")
        if not isinstance(img, np.ndarray):
            error_msg = "Input image must be a NumPy ndarray."
            logger.error(error_msg)
            raise ValueError(error_msg)

        try:
            self.config.update(**kwargs)
            logger.debug(f"Configuration updated with parameters: {kwargs}")

            img = PreprocessEquirectangularImage.preprocess(img, **kwargs)

            x_grid, y_grid = self.grid_generation.projection_grid()
            logger.debug("Forward grid generated successfully.")

            lat, lon = self.projection.from_projection_to_spherical(x_grid, y_grid)
            logger.debug("Forward projection computed successfully.")

            map_x, map_y = self.transformer.spherical_to_image_coords(lat, lon, img.shape[:2])
            logger.debug("Coordinates transformed to image space successfully.")

            projected_img = self.interpolation.interpolate(img, map_x, map_y)
            logger.info("Forward projection completed successfully.")
            return projected_img

        except (GridGenerationError, ProcessingError, TransformationError, InterpolationError) as e:
            logger.error(f"Forward projection failed: {e}")
            raise
        except Exception as e:
            logger.exception("Unexpected error during forward projection.")
            raise ProcessingError(f"Unexpected error during forward projection: {e}")

    def backward(self, rect_img: np.ndarray, return_mask: bool=False, **kwargs: Any) -> np.ndarray:
        """
        Backward projection of a rectilinear image to equirectangular.

        Args:
            rect_img (np.ndarray): The rectilinear image.
            **kwargs (Any): Additional parameters to override projection configuration.

        Returns:
            np.ndarray: Back-projected equirectangular image.

        Raises:
            ValueError: If the input image is not a valid NumPy array.
            GridGenerationError: If grid generation fails.
            ProcessingError: If backward projection fails.
            TransformationError: If coordinate transformation fails.
            InterpolationError: If interpolation fails.
        """
        logger.debug("Starting backward projection.")
        if not isinstance(rect_img, np.ndarray):
            error_msg = "Rectilinear image must be a NumPy ndarray."
            logger.error(error_msg)
            raise ValueError(error_msg)

        try:
            self.config.update(**kwargs)
            logger.debug(f"Configuration updated with parameters: {kwargs}")
      
            lon_grid, lat_grid = self.grid_generation.spherical_grid()
            logger.debug("Backward grid generated successfully.")

            x, y, mask = self.projection.from_spherical_to_projection(lat_grid, lon_grid)
            logger.debug("Backward projection computed successfully.")

            map_x, map_y = self.transformer.projection_to_image_coords(x, y, self.config.config_object)
            logger.debug("Grid coordinates transformed to image space successfully.")

            back_projected_img = self.interpolation.interpolate(
                rect_img, map_x, map_y, mask if kwargs.get("return_mask", True) else None
            )
            logger.info("Backward projection completed successfully.")
            if return_mask:
                return cv2.flip(back_projected_img, 0), cv2.flip(mask * 1,0) == 1

            return cv2.flip(back_projected_img, 0)

        except (GridGenerationError, ProcessingError, TransformationError, InterpolationError) as e:
            logger.error(f"Backward projection failed: {e}")
            raise
        except Exception as e:
            logger.exception("Unexpected error during backward projection.")
            raise ProcessingError(f"Unexpected error during backward projection: {e}")

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/registry.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/registry.py

from typing import Any, Dict, Optional, Type, Union
from .base.config import BaseProjectionConfig
from .processor import ProjectionProcessor
from .exceptions import RegistrationError
import logging

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.registry')

class ProjectionRegistry:
    """
    Registry for managing projection configurations and their components.
    """
    _registry: Dict[str, Dict[str, Type[Any]]] = {}

    @classmethod
    def register(cls, name: str, components: Dict[str, Type[Any]]) -> None:
        """
        Register a projection with its required components.

        Args:
            name (str): Name of the projection (e.g., 'gnomonic').
            components (Dict[str, Type[Any]]): A dictionary containing:
                - 'config': Configuration class
                - 'grid_generation': Grid generation class
                - 'projection_strategy': Projection strategy class
                - 'interpolation' (optional): Interpolation class
                - 'transformer': Transformation class (optional)

        Raises:
            RegistrationError: If required components are missing or invalid.
        """
        logger.debug(f"Attempting to register projection '{name}' with components: {list(components.keys())}")
        required_keys = {"config", "grid_generation", "projection_strategy"}
        missing_keys = required_keys - components.keys()
        if missing_keys:
            error_msg = f"Components must include {required_keys}. Missing keys: {missing_keys}"
            logger.error(error_msg)
            raise RegistrationError(error_msg)

        for key in ["interpolation", "transformer"]:
            if key in components:
                if not isinstance(components[key], type):
                    error_msg = f"'{key}' component must be a class type."
                    logger.error(error_msg)
                    raise RegistrationError(error_msg)
                logger.debug(f"'{key}' component validated as a class type.")

        cls._registry[name] = components
        logger.info(f"Projection '{name}' registered successfully.")

    @classmethod
    def get_projection(
        cls, 
        name: str, 
        return_processor: bool = False, 
        **kwargs: Any
    ) -> Union[BaseProjectionConfig, ProjectionProcessor]:
        """
        Retrieve a configured projection by name.

        Args:
            name (str): Name of the projection to retrieve.
            return_processor (bool): Whether to return the processor instead of the config.
            **kwargs (Any): Configuration parameters to override defaults.

        Returns:
            Union[BaseProjectionConfig, ProjectionProcessor]: Depending on `return_processor`.

        Raises:
            RegistrationError: If the projection name is not found or components are missing.
        """
        logger.debug(f"Retrieving projection '{name}' with override parameters: {kwargs}")
        if name not in cls._registry:
            error_msg = f"Projection '{name}' not found in the registry."
            logger.error(error_msg)
            raise RegistrationError(error_msg)

        components = cls._registry[name]
        try:
            ConfigClass = components["config"]
            GridGenerationClass = components["grid_generation"]
            ProjectionStrategyClass = components["projection_strategy"]
            InterpolationClass = components.get("interpolation", None)
            TransformerClass = components.get("transformer", None)
            logger.debug(f"Components for projection '{name}': {list(components.keys())}")
        except KeyError as e:
            error_msg = f"Missing component in the registry: {e}"
            logger.error(error_msg)
            raise RegistrationError(error_msg) from e

        # Instantiate the configuration object
        try:
            config_instance = ConfigClass(**kwargs)
            logger.debug(f"Configuration instance for projection '{name}' created successfully.")
        except Exception as e:
            error_msg = f"Failed to instantiate config class '{ConfigClass.__name__}': {e}"
            logger.exception(error_msg)
            raise RegistrationError(error_msg) from e

        # Create a BaseProjectionConfig and attach the necessary methods
        base_config = BaseProjectionConfig(config_instance)
        base_config.create_projection = lambda: ProjectionStrategyClass(config_instance)
        base_config.create_grid_generation = lambda: GridGenerationClass(config_instance)
        if InterpolationClass:
            base_config.create_interpolation = lambda: InterpolationClass(config_instance)
        if TransformerClass:
            base_config.create_transformer = lambda: TransformerClass(config_instance)

        if return_processor:
            logger.debug(f"Returning ProjectionProcessor for projection '{name}'.")
            return ProjectionProcessor(base_config)

        logger.debug(f"Returning BaseProjectionConfig for projection '{name}'.")
        return base_config

    @classmethod
    def list_projections(cls) -> list:
        """
        List all registered projections.

        Returns:
            list: A list of projection names.
        """
        logger.debug("Listing all registered projections.")
        projections = list(cls._registry.keys())
        logger.info(f"Registered projections: {projections}")
        return projections

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/projection/utils.py ###
import cv2
import numpy as np
import logging


class PreprocessEquirectangularImage:
    # Set up the logger for the class
    logger = logging.getLogger("EquirectangularImage")
    logger.setLevel(logging.DEBUG)

    @classmethod
    def extend_height(cls, image, shadow_angle):
        """
        Extends the height of an equirectangular image based on the given additional FOV.
        """
        cls.logger.info("Starting height extension with shadow_angle=%.2f", shadow_angle)

        if not isinstance(image, np.ndarray):
            cls.logger.error("Image is not a valid numpy array.")
            raise TypeError("Image must be a numpy array.")
        if shadow_angle <= 0:
            cls.logger.info("No extension needed as shadow_angle=0.")
            return image  # No extension needed

        fov_original = 180.0
        height, width, channels = image.shape
        h_prime = int((shadow_angle / fov_original) * height)
        cls.logger.debug("Original height: %d, Additional height: %d", height, h_prime)

        black_extension = np.zeros((h_prime, width, channels), dtype=image.dtype)
        extended_image = np.vstack((image, black_extension))

        cls.logger.info("Height extension complete. New height: %d", extended_image.shape[0])
        return extended_image

    @classmethod
    def rotate(cls, image, delta_lat, delta_lon):
        """
        Rotates an equirectangular image based on latitude and longitude shifts.
        """
        cls.logger.info("Starting rotation with delta_lat=%.2f, delta_lon=%.2f", delta_lat, delta_lon)

        # if image.ndim != 3 or image.shape[2] not in [1, 3, 4]:
        #    cls.logger.error("Invalid image dimensions. Expected a 3D array with 1, 3, or 4 channels.")
        #    raise ValueError("Input image must be a 3D array with 1, 3, or 4 channels.")

        H, W, C = image.shape
        cls.logger.debug("Image dimensions: Height=%d, Width=%d, Channels=%d", H, W, C)

        x = np.linspace(0, W - 1, W)
        y = np.linspace(0, H - 1, H)
        xv, yv = np.meshgrid(x, y)

        lon = (xv / (W - 1)) * 360.0 - 180.0
        lat = 90.0 - (yv / (H - 1)) * 180.0

        lat_rad = np.radians(lat)
        lon_rad = np.radians(lon)
        x_sphere = np.cos(lat_rad) * np.cos(lon_rad)
        y_sphere = np.cos(lat_rad) * np.sin(lon_rad)
        z_sphere = np.sin(lat_rad)

        delta_lat_rad = np.radians(delta_lat)
        delta_lon_rad = np.radians(delta_lon)

        x_rot = x_sphere
        y_rot = y_sphere * np.cos(delta_lat_rad) - z_sphere * np.sin(delta_lat_rad)
        z_rot = y_sphere * np.sin(delta_lat_rad) + z_sphere * np.cos(delta_lat_rad)

        x_final = x_rot * np.cos(delta_lon_rad) - y_rot * np.sin(delta_lon_rad)
        y_final = x_rot * np.sin(delta_lon_rad) + y_rot * np.cos(delta_lon_rad)
        z_final = z_rot

        lon_final = np.arctan2(y_final, x_final)
        lat_final = np.arcsin(z_final)

        lon_final_deg = np.degrees(lon_final)
        lat_final_deg = np.degrees(lat_final)

        x_rot_map = ((lon_final_deg + 180.0) / 360.0) * (W - 1)
        y_rot_map = ((90.0 - lat_final_deg) / 180.0) * (H - 1)

        map_x = x_rot_map.astype(np.float32)
        map_y = y_rot_map.astype(np.float32)

        rotated_image = cv2.remap(
            image,
            map_x,
            map_y,
            interpolation=cv2.INTER_LINEAR,
            borderMode=cv2.BORDER_WRAP
        )

        cls.logger.info("Rotation complete.")
        return rotated_image

    @classmethod
    def preprocess(cls, image, **kwargs):
        """
        Preprocess an equirectangular image by extending its height and then rotating it.

        Parameters:
            image (np.ndarray): Input equirectangular image.
            **kwargs: Parameters for preprocessing:
                - shadow_angle (float): Additional field of view in degrees to extend. Default is 0.
                - delta_lat (float): Latitude rotation in degrees. Default is 0.
                - delta_lon (float): Longitude rotation in degrees. Default is 0.

        Returns:
            np.ndarray: Preprocessed image.
        """
        shadow_angle = kwargs.get("shadow_angle", 0)
        delta_lat = kwargs.get("delta_lat", 0)
        delta_lon = kwargs.get("delta_lon", 0)

        cls.logger.info("Starting preprocessing with parameters: shadow_angle=%.2f, delta_lat=%.2f, delta_lon=%.2f",
                        shadow_angle, delta_lat, delta_lon)

        # Step 1: Extend the image height
        processed_image = cls.extend_height(image, shadow_angle)

        # Step 2: Rotate the image
        processed_image = cls.rotate(processed_image, delta_lat, delta_lon)

        cls.logger.info("Preprocessing complete.")
        return processed_image

    @classmethod
    def save_image(cls, image, file_path):
        """
        Saves the current image to the specified file path.
        """
        if not isinstance(image, np.ndarray):
            cls.logger.error("Image is not a valid numpy array.")
            raise TypeError("Image must be a numpy array.")
        cv2.imwrite(file_path, image)
        cls.logger.info("Image saved to %s", file_path)

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/tests/conftest.py ###
# /Users/robinsongarcia/projects/gnomonic/tests/conftest.py

# Standard library imports
from unittest.mock import Mock

# Third-party imports
import pytest

# Local imports
from projection.gnomonic.config import GnomonicConfig
from projection.base.config import BaseProjectionConfig
from projection.processor import ProjectionProcessor

@pytest.fixture
def mock_grid_generation():
    """
    Fixture to provide a mock grid generation object with a create_grid method.
    """
    mock = Mock()
    mock.create_grid.return_value = (Mock(), Mock())  # Mocked grid arrays
    return mock

@pytest.fixture
def projection_processor(mock_grid_generation):
    """
    Fixture to provide a ProjectionProcessor with mocked components.
    """
    config = GnomonicConfig()
    base_config = BaseProjectionConfig(config)
    base_config.create_projection = Mock()  # Mock create_projection to avoid NotImplementedError
    base_config.create_grid_generation = Mock(return_value=mock_grid_generation)
    processor = ProjectionProcessor(base_config)
    return processor

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/tests/test_config.py ###
import pytest
from projection.base.config import BaseProjectionConfig, BaseProjectionConfigModel
from projection.gnomonic.config import GnomonicConfig
from projection.exceptions import ConfigurationError
import cv2

def test_base_projection_config_valid():
    gnomonic_config = GnomonicConfig()
    base_config = BaseProjectionConfig(gnomonic_config)
    assert isinstance(base_config.params, BaseProjectionConfigModel), "BaseProjectionConfigModel not initialized correctly"

def test_base_projection_config_invalid():
    with pytest.raises(ConfigurationError) as exc_info:
        BaseProjectionConfig(config_object={})  # Missing 'config' attribute
    assert "Configuration object must have a 'config' attribute." in str(exc_info.value)

def test_gnomonic_config_valid():
    config = GnomonicConfig(
        R=1,
        phi1_deg=0,
        lam0_deg=0,
        fov_deg=90,
        x_points=1024,
        y_points=1024,
        lon_points=2048,
        lat_points=1024,
        x_min=-1,
        x_max=1,
        y_min=-1,
        y_max=1,
        lon_min=-180,
        lon_max=180,
        lat_min=-90,
        lat_max=90,
        interpolation=cv2.INTER_LINEAR,
        borderMode=cv2.BORDER_CONSTANT,
        borderValue=0
    )
    assert config.R == 1
    assert config.fov_deg == 90

def test_gnomonic_config_invalid_fov():
    with pytest.raises(ConfigurationError) as exc_info:
        GnomonicConfig(fov_deg=200)  # Invalid fov_deg
    assert "Field of view (fov_deg) must be between 0 and 180 degrees." in str(exc_info.value)

def test_gnomonic_config_update():
    config = GnomonicConfig(fov_deg=90)
    config.update(fov_deg=120)
    assert config.fov_deg == 120
    with pytest.raises(ConfigurationError) as exc_info:
        config.update(fov_deg=-10)  # Invalid update
    assert "Field of view (fov_deg) must be between 0 and 180 degrees." in str(exc_info.value)

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/tests/test_grid.py ###
import pytest
from projection.base.grid import BaseGridGeneration
from projection.gnomonic.grid import GnomonicGridGeneration
from projection.gnomonic.config import GnomonicConfig
from projection.exceptions import GridGenerationError, ConfigurationError
import numpy as np

class MockGridGeneration(BaseGridGeneration):
    def _create_grid(self, direction: str):
        return np.zeros((10, 10)), np.zeros((10, 10))

def test_base_grid_generation_invalid_direction():
    base_grid = BaseGridGeneration()
    with pytest.raises(GridGenerationError) as exc_info:
        base_grid.create_grid('invalid_direction')
    assert "Direction must be 'forward' or 'backward'." in str(exc_info.value)

def test_base_grid_generation_not_implemented():
    base_grid = BaseGridGeneration()
    with pytest.raises(GridGenerationError) as exc_info:
        base_grid.create_grid('forward')  # Should call _create_grid and raise
    assert "Subclasses must implement create_grid." in str(exc_info.value)

def test_gnomonic_grid_generation_forward():
    config = GnomonicConfig()
    grid_gen = GnomonicGridGeneration(config)
    x_grid, y_grid = grid_gen.create_grid('forward')
    assert x_grid.shape == (config.y_points, config.x_points)
    assert y_grid.shape == (config.y_points, config.x_points)
    assert np.all(x_grid >= config.x_min) and np.all(x_grid <= config.x_max)
    assert np.all(y_grid >= config.y_min) and np.all(y_grid <= config.y_max)

def test_gnomonic_grid_generation_backward():
    config = GnomonicConfig()
    grid_gen = GnomonicGridGeneration(config)
    lon_grid, lat_grid = grid_gen.create_grid('backward')
    assert lon_grid.shape == (config.lat_points, config.lon_points)
    assert lat_grid.shape == (config.lat_points, config.lon_points)
    assert np.all(lon_grid >= config.lon_min) and np.all(lon_grid <= config.lon_max)
    assert np.all(lat_grid >= config.lat_min) and np.all(lat_grid <= config.lat_max)

def test_gnomonic_grid_generation_invalid_direction():
    config = GnomonicConfig()
    grid_gen = GnomonicGridGeneration(config)
    with pytest.raises(GridGenerationError) as exc_info:
        grid_gen.create_grid('invalid')
    assert "Direction must be 'forward' or 'backward'." in str(exc_info.value)

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/tests/test_integration_backward.py ###
import pytest
from unittest.mock import Mock
from projection.processor import ProjectionProcessor
from projection.gnomonic.config import GnomonicConfig
from projection.base.config import BaseProjectionConfig
from projection.exceptions import ProcessingError, GridGenerationError
import numpy as np

def test_backward_projection_pipeline():
    config = GnomonicConfig()
    base_config = BaseProjectionConfig(config)
    base_config.create_projection = Mock()  # Mock create_projection to avoid NotImplementedError
    
    # Create a mock for grid generation with a create_grid method
    mock_grid_generation = Mock()
    mock_grid_generation.create_grid.return_value = (np.zeros((2, 2)), np.zeros((2, 2)))
    base_config.create_grid_generation = Mock(return_value=mock_grid_generation)
    
    processor = ProjectionProcessor(base_config)

    rect_img = np.ones((2, 2, 3), dtype=np.uint8) * 255
    back_projected_img = processor.backward(rect_img)
    assert back_projected_img.shape == rect_img.shape
    assert not np.all(back_projected_img == 0)

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/tests/test_integration_forward.py ###
import pytest
from unittest.mock import Mock
from projection.processor import ProjectionProcessor
from projection.gnomonic.config import GnomonicConfig
from projection.base.config import BaseProjectionConfig
from projection.exceptions import ProcessingError, GridGenerationError
import numpy as np

def test_forward_projection_pipeline():
    config = GnomonicConfig()
    base_config = BaseProjectionConfig(config)
    base_config.create_projection = Mock()  # Mock create_projection to avoid NotImplementedError
    
    # Create a mock for grid generation with a create_grid method
    mock_grid_generation = Mock()
    mock_grid_generation.create_grid.return_value = (np.zeros((2, 2)), np.zeros((2, 2)))
    base_config.create_grid_generation = Mock(return_value=mock_grid_generation)
    
    processor = ProjectionProcessor(base_config)

    input_img = np.ones((2, 2, 3), dtype=np.uint8) * 255
    projected_img = processor.forward(input_img)
    assert projected_img.shape == input_img.shape
    assert not np.all(projected_img == 0)

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/tests/test_interpolation.py ###
import pytest
from projection.base.interpolation import BaseInterpolation
from projection.gnomonic.config import GnomonicConfig
from projection.exceptions import InterpolationError
import numpy as np
import cv2

def test_base_interpolation_apply_mask():
    config = GnomonicConfig()
    interpolation = BaseInterpolation(config)
    input_img = np.ones((2, 2, 3), dtype=np.uint8) * 255  # Correct shape to match broadcasting
    map_x = np.array([[0, 1], [0, 1]])
    map_y = np.array([[0, 1], [0, 1]])
    mask = np.array([[1, 0], [1, 0]], dtype=np.uint8)
    output_img = interpolation.interpolate(input_img, map_x, map_y, mask)
    assert np.array_equal(output_img, np.array([[[255, 255, 255], [0, 0, 0]], [[255, 255, 255], [0, 0, 0]]]))

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/tests/test_processor.py ###
import pytest
from unittest.mock import Mock
from projection.processor import ProjectionProcessor
from projection.base.config import BaseProjectionConfig
from projection.exceptions import ProcessingError, GridGenerationError, InterpolationError
from projection.gnomonic.config import GnomonicConfig
import numpy as np

def test_processor_initialization():
    config = GnomonicConfig()
    base_config = BaseProjectionConfig(config)
    base_config.create_projection = Mock()  # Mock to avoid NotImplementedError
    base_config.create_grid_generation = Mock()
    processor = ProjectionProcessor(base_config)
    assert isinstance(processor, ProjectionProcessor)

def test_processor_forward_invalid_image():
    config = GnomonicConfig()
    base_config = BaseProjectionConfig(config)
    base_config.create_projection = Mock()
    base_config.create_grid_generation = Mock()
    processor = ProjectionProcessor(base_config)
    with pytest.raises(ValueError):
        processor.forward("not_an_image")

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/tests/test_registry.py ###
import pytest
from projection.registry import ProjectionRegistry
from projection.gnomonic.config import GnomonicConfig
from projection.gnomonic.grid import GnomonicGridGeneration
from projection.gnomonic.strategy import GnomonicProjectionStrategy
from projection.base.interpolation import BaseInterpolation
from projection.exceptions import RegistrationError
from projection.processor import ProjectionProcessor  # Added import
import logging

def test_register_projection_success():
    ProjectionRegistry._registry = {}  # Reset registry for test
    ProjectionRegistry.register("test_projection", {
        "config": GnomonicConfig,
        "grid_generation": GnomonicGridGeneration,
        "projection_strategy": GnomonicProjectionStrategy,
        "interpolation": BaseInterpolation,
    })
    assert "test_projection" in ProjectionRegistry._registry

def test_register_projection_missing_components():
    ProjectionRegistry._registry = {}
    with pytest.raises(RegistrationError) as exc_info:
        ProjectionRegistry.register("incomplete_projection", {
            "config": GnomonicConfig,
            "grid_generation": GnomonicGridGeneration,
            # Missing 'projection_strategy'
        })
    assert "Components must include {'grid_generation', 'projection_strategy', 'config'}. Missing keys: {'projection_strategy'}" in str(exc_info.value)

def test_register_projection_invalid_component_type():
    ProjectionRegistry._registry = {}
    with pytest.raises(RegistrationError) as exc_info:
        ProjectionRegistry.register("invalid_component_projection", {
            "config": GnomonicConfig,
            "grid_generation": "NotAClass",  # Invalid type
            "projection_strategy": GnomonicProjectionStrategy,
        })
    assert "'grid_generation' component must be a class type." in str(exc_info.value)

def test_get_projection_success():
    ProjectionRegistry._registry = {}
    ProjectionRegistry.register("test_projection", {
        "config": GnomonicConfig,
        "grid_generation": GnomonicGridGeneration,
        "projection_strategy": GnomonicProjectionStrategy,
        "interpolation": BaseInterpolation,
    })
    projection = ProjectionRegistry.get_projection("test_projection")
    assert hasattr(projection, "create_projection")
    assert hasattr(projection, "create_grid_generation")
    assert hasattr(projection, "create_interpolation")

def test_get_projection_not_registered():
    ProjectionRegistry._registry = {}
    with pytest.raises(RegistrationError) as exc_info:
        ProjectionRegistry.get_projection("nonexistent_projection")
    assert "Projection 'nonexistent_projection' not found in the registry." in str(exc_info.value)

def test_get_projection_with_processor():
    ProjectionRegistry._registry = {}
    ProjectionRegistry.register("test_projection", {
        "config": GnomonicConfig,
        "grid_generation": GnomonicGridGeneration,
        "projection_strategy": GnomonicProjectionStrategy,
        "interpolation": BaseInterpolation,
    })
    projection_processor = ProjectionRegistry.get_projection("test_projection", return_processor=True)
    assert isinstance(projection_processor, ProjectionProcessor)

def test_list_projections():
    ProjectionRegistry._registry = {}
    ProjectionRegistry.register("proj1", {
        "config": GnomonicConfig,
        "grid_generation": GnomonicGridGeneration,
        "projection_strategy": GnomonicProjectionStrategy,
    })
    ProjectionRegistry.register("proj2", {
        "config": GnomonicConfig,
        "grid_generation": GnomonicGridGeneration,
        "projection_strategy": GnomonicProjectionStrategy,
    })
    projections = ProjectionRegistry.list_projections()
    assert "proj1" in projections
    assert "proj2" in projections
    assert len(projections) == 2

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/tests/test_strategy.py ###
# tests/test_strategy.py

import pytest
from projection.base.strategy import BaseProjectionStrategy
from projection.gnomonic.strategy import GnomonicProjectionStrategy
from projection.gnomonic.config import GnomonicConfig
from projection.exceptions import ProcessingError
import numpy as np

class MockProjectionStrategy(BaseProjectionStrategy):
    def forward(self, x: np.ndarray, y: np.ndarray):
        return np.zeros_like(x), np.zeros_like(y)
    
    def backward(self, lat: np.ndarray, lon: np.ndarray):
        return np.zeros_like(lat), np.zeros_like(lon), np.ones_like(lat)

def test_base_projection_strategy_forward_not_implemented():
    base_strategy = BaseProjectionStrategy()
    with pytest.raises(ProcessingError) as exc_info:
        base_strategy.forward(np.array([1,2]), np.array([3,4]))
    assert "x and y must be NumPy ndarrays." not in str(exc_info.value)
    assert "Subclasses must implement forward." in str(exc_info.value)

def test_base_projection_strategy_backward_not_implemented():
    base_strategy = BaseProjectionStrategy()
    with pytest.raises(ProcessingError) as exc_info:
        base_strategy.backward(np.array([1,2]), np.array([3,4]))
    assert "lat and lon must be NumPy ndarrays." not in str(exc_info.value)
    assert "Subclasses must implement backward." in str(exc_info.value)

def test_gnomonic_projection_strategy_forward():
    config = GnomonicConfig()
    strategy = GnomonicProjectionStrategy(config)
    x = np.array([[0,1], [2,3]])
    y = np.array([[4,5], [6,7]])
    lat, lon = strategy.forward(x, y)
    assert lat.shape == x.shape
    assert lon.shape == y.shape

def test_gnomonic_projection_strategy_backward():
    config = GnomonicConfig()
    strategy = GnomonicProjectionStrategy(config)
    lat = np.array([[0,45], [90,135]])
    lon = np.array([[-180, -90], [0, 90]])
    x, y, mask = strategy.backward(lat, lon)
    assert x.shape == lat.shape
    assert y.shape == lon.shape
    assert mask.shape == lat.shape
    assert np.all(mask == True)  # Based on GnomonicConfig defaults

def test_gnomonic_projection_strategy_invalid_inputs():
    config = GnomonicConfig()
    strategy = GnomonicProjectionStrategy(config)
    with pytest.raises(ProcessingError):
        strategy.forward([1,2], np.array([3,4]))  # x is not np.ndarray
    with pytest.raises(ProcessingError):
        strategy.backward(np.array([1,2]), "invalid_lon")  # lon is not np.ndarray

### /Users/robinsongarcia/projects/Mestrado2/PanorAi/panorai/submodules/projections/tests/test_transform.py ###
import pytest
from projection.base.transform import CoordinateTransformer
from projection.gnomonic.config import GnomonicConfig
from projection.exceptions import TransformationError, ConfigurationError
import numpy as np

def test_latlon_to_image_coords_valid():
    config = GnomonicConfig()
    lat = np.array([[0, 45], [90, -45]])
    lon = np.array([[-180, 0], [180, 90]])
    shape = (180, 360, 3)  # Example equirectangular image shape
    map_x, map_y = CoordinateTransformer.latlon_to_image_coords(lat, lon, config, shape)
    assert map_x.shape == lat.shape
    assert map_y.shape == lat.shape

def test_latlon_to_image_coords_invalid_inputs():
    config = GnomonicConfig()
    # First call: Invalid latitude input, but include all required parameters
    with pytest.raises(TransformationError):
        CoordinateTransformer.latlon_to_image_coords("lat", np.array([0]), config, (100, 100))
    
    # Second call: Missing 'lon_min' attribute
    with pytest.raises(ConfigurationError):
        config_invalid = GnomonicConfig()
        del config_invalid.lon_min  # Remove required attribute
        CoordinateTransformer.latlon_to_image_coords(np.array([0]), np.array([0]), config_invalid, (100, 100))

def test_xy_to_image_coords_valid():
    config = GnomonicConfig()
    x = np.array([[0, 1], [2, 3]])
    y = np.array([[4, 5], [6, 7]])
    map_x, map_y = CoordinateTransformer.xy_to_image_coords(x, y, config)
    assert map_x.shape == x.shape
    assert map_y.shape == y.shape

def test_xy_to_image_coords_invalid_inputs():
    config = GnomonicConfig()
    with pytest.raises(TransformationError):
        CoordinateTransformer.xy_to_image_coords("x", np.array([0]), config)
    with pytest.raises(ConfigurationError):
        config_invalid = GnomonicConfig()
        del config_invalid.x_min  # Remove required attribute
        CoordinateTransformer.xy_to_image_coords(np.array([0]), np.array([0]), config_invalid)

def test_xy_to_image_coords_invalid_shape():
    config = GnomonicConfig()
    x = np.array([0,1,2])
    y = np.array([3,4,5])
    with pytest.raises(TransformationError):
        CoordinateTransformer.latlon_to_image_coords(np.array([0,1,2]), np.array([3,4,5]), config, (100,))

def test_latlon_to_image_coords_computation():
    config = GnomonicConfig(
        lon_min=0,
        lon_max=360,
        lat_min=-90,
        lat_max=90
    )
    lat = np.array([[0, 90], [-90, 45]])
    lon = np.array([[0, 180], [360, 90]])
    shape = (180, 360, 3)
    map_x, map_y = CoordinateTransformer.latlon_to_image_coords(lat, lon, config, shape)
    expected_map_x = (lon - config.lon_min) / (config.lon_max - config.lon_min) * (shape[1] - 1)
    expected_map_y = (config.lat_max - lat) / (config.lat_max - config.lat_min) * (shape[0] - 1)
    assert np.allclose(map_x, expected_map_x)
    assert np.allclose(map_y, expected_map_y)

